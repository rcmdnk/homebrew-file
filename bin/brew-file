#!/usr/bin/env python3
from __future__ import annotations

import argparse
import copy
import json
import logging
import os
import platform
import re
import shlex
import shutil
import subprocess
import sys
import tempfile
from _io import TextIOWrapper
from collections.abc import Generator
from dataclasses import dataclass, field
from pathlib import Path
from types import TracebackType
from typing import Any, Literal, TypedDict, cast
from urllib.parse import quote

__prog__ = 'brew-file'
__description__ = """
Brew-file: Manager for packages of Homebrew.

https://github.com/rcmdnk/homebrew-file

requirement: Python 3.9.0 or later
"""
__author__ = 'rcmdnk'
__copyright__ = 'Copyright (c) 2013 rcmdnk'
__credits__ = ['rcmdnk']
__license__ = 'MIT'
__version__ = '10.1.2'
__date__ = '17/Aug/2025'
__maintainer__ = 'rcmdnk'
__email__ = 'rcmdnk@gmail.com'
__status__ = 'Prototype'


class LogFormatter(logging.Formatter):
    """Formatter to add color to log messages."""

    def __init__(self) -> None:
        self.default_format = '%(message)s'
        self.formats = {
            logging.DEBUG: f'[DEBUG] {self.default_format}',
            logging.INFO: f'{self.default_format}',
            logging.WARNING: f'[WARNING] {self.default_format}',
            logging.ERROR: f'[ERROR] {self.default_format}',
            logging.CRITICAL: f'[CRITICAL] {self.default_format}',
        }
        if sys.stdout.isatty():
            colors = {
                logging.WARNING: '33',
                logging.ERROR: '31',
                logging.CRITICAL: '31',
            }
            for level, color in colors.items():
                self.formats[level] = (
                    f'\033[{color};1m{self.formats[level]}\033[m'
                )

    def format(self, record: logging.LogRecord) -> str:
        fmt = self.formats.get(record.levelno, self.default_format)
        formatter = logging.Formatter(fmt)
        return formatter.format(record)


def is_mac() -> bool:
    return platform.system() == 'Darwin'


def to_bool(val: bool | int | str) -> bool:
    if isinstance(val, bool):
        return val
    if isinstance(val, int) or (
        isinstance(val, str) and val.lstrip('+-').isdigit()
    ):
        return bool(int(val))
    return isinstance(val, str) and val.lower() == 'true'


def to_num(val: bool | int | str) -> int:
    if isinstance(val, bool):
        return int(val)
    if isinstance(val, int) or (
        isinstance(val, str) and val.lstrip('+-').isdigit()
    ):
        return int(val)
    if isinstance(val, str) and val.lower() == 'true':
        return 1
    return 0


shell_envs: dict[str, str] = {
    'HOSTNAME': os.uname().nodename,
    'HOSTTYPE': os.uname().machine,
    'OSTYPE': subprocess.run(
        ['bash', '-c', 'echo $OSTYPE'],
        capture_output=True,
        text=True,
        check=False,
    ).stdout.strip(),
    'PLATFORM': sys.platform,
}


def expandpath(path: str | Path) -> Path:
    path = str(path)
    for k, v in shell_envs.items():
        for kk in [f'${k}', f'${{{k}}}']:
            if kk in path:
                path = path.replace(kk, v)
    path = re.sub(
        r'(?<!\\)\$(\w+|\{([^}]*)\})',
        lambda x: os.getenv(x.group(2) or x.group(1), ''),
        path,
    )
    path = path.replace('\\$', '$')
    return Path(path).expanduser()


def home_tilde(path: str | Path) -> str:
    return str(path).replace(os.environ['HOME'], '~')


@dataclass
class OpenWrapper:
    """Wrapper function to open a file even if it doesn't exist."""

    name: str
    mode: Literal['w', 'r', 'a'] = 'w'

    def __enter__(self) -> TextIOWrapper:
        Path(self.name).parent.mkdir(parents=True, exist_ok=True)
        self.file = Path(self.name).open(self.mode)
        return self.file

    def __exit__(
        self,
        exception_type: type[BaseException] | None,
        exception_value: BaseException | None,
        traceback: TracebackType | None,
    ) -> bool:
        if exception_type is not None:
            return False
        self.file.close()
        return True


@dataclass
class StrRe(str):
    """Str wrapper to use regex especially for match-case."""

    var: str

    def __eq__(self, pattern: object) -> bool:
        return re.search(str(pattern), self.var) is not None

    def __hash__(self) -> int:
        return hash(self.var)


class ProcParams(TypedDict):
    """Parameters for BrewHelper.proc()."""

    cmd: str | list[str]
    print_cmd: bool
    print_out: bool
    exit_on_err: bool
    separate_err: bool
    print_err: bool
    env: dict[str, str] | None
    cwd: str | Path | None
    dryrun: bool


class CmdError(Exception):
    """Exception at command execution."""

    def __init__(self, message: str, return_code: int) -> None:
        super().__init__(message)
        self.return_code = return_code


@dataclass
class BrewHelper:
    """Helper functions for BrewFile."""

    opt: dict[str, Any] = field(default_factory=dict)

    def __post_init__(self) -> None:
        self.log = logging.getLogger(__name__)

        self.all_info: dict[str, dict[str, Any]] = {}
        self.info: dict[str, dict[str, Any]] = {}

        self.packages: dict[str, list[str]] = {}

        self.aliases: dict[str, dict[str, dict[str, str]]] = {}
        self.taps: dict[str, Any] | None = None
        self.leaves_list: list[str] | None = None
        self.leaves_list_on_request: list[str] | None = None

    def readstdout(
        self,
        proc: subprocess.Popen[str],
    ) -> Generator[str, None, None]:
        if proc.stdout is None:
            return
        for out_line in iter(proc.stdout.readline, ''):
            line = out_line.rstrip()
            if line == '':
                continue
            yield line

    def proc(
        self,
        cmd: str | list[str],
        print_cmd: bool = True,
        print_out: bool = True,
        exit_on_err: bool = True,
        separate_err: bool = False,
        print_err: bool = True,
        env: dict[str, str] | None = None,
        cwd: str | Path | None = None,
        dryrun: bool = False,
    ) -> tuple[int, list[str]]:
        """Get process output."""
        if env is None:
            env = {}
        if not isinstance(cmd, list):
            cmd = shlex.split(cmd)
        cmd_orig = ' '.join(['$', *cmd])
        if cmd[0] == 'brew':
            cmd[0] = self.opt.get('brew_cmd', 'brew')
        if print_cmd or dryrun:
            self.log.info(cmd_orig)
        if dryrun:
            return 0, [' '.join(cmd)]
        all_env = os.environ.copy()
        all_env.update(env)
        lines = []
        try:
            if separate_err:
                stderr = None if print_err else subprocess.PIPE
            else:
                stderr = subprocess.STDOUT
            p = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=stderr,
                text=True,
                env=all_env,
                cwd=cwd,
            )
            for line in self.readstdout(p):
                lines.append(line)
                if print_out:
                    self.log.info(line)
            ret = p.wait()
        except OSError as e:
            if separate_err:
                if print_err:
                    self.log.error(str(e))  # noqa: TRY400
            else:
                lines += str(e).splitlines()
                if print_out:
                    self.log.info(str(e))
            ret = e.errno if e.errno is not None else 1

        if exit_on_err and ret != 0:
            output = '\n'.join(lines)
            msg = f'Failed at command: {" ".join(cmd)}\n{output}'
            raise CmdError(msg, ret)
        return ret, lines

    def brew_val(self, name: str) -> str:
        if name not in self.opt:
            _, lines = self.proc('brew --' + name, False, False)
            self.opt[name] = lines[0]
        return self.opt[name]

    def name_key(self) -> str:
        return 'full_name' if self.opt['full_name'] else 'name'

    def token_key(self) -> str:
        return 'full_token' if self.opt['full_name'] else 'token'

    def get_packages(self, package_type: str) -> list[str]:
        if (packages := self.packages.get(package_type, None)) is not None:
            return packages
        _, lines = self.proc(
            cmd=f'brew {package_type}',
            print_cmd=False,
            print_out=False,
            exit_on_err=True,
            separate_err=True,
        )
        self.packages[package_type] = lines
        return self.packages[package_type]

    def get_formulae(self) -> list[str]:
        return self.get_packages('formulae')

    def get_casks(self) -> list[str]:
        return self.get_packages('casks')

    def get_json_info(
        self, args: str, exit_on_err: bool
    ) -> dict[str, Any] | list[str]:
        ret, lines = self.proc(
            cmd=f'brew info --json=v2 {args}',
            print_cmd=False,
            print_out=False,
            exit_on_err=exit_on_err,
            separate_err=False,
        )
        if ret != 0:
            return lines
        lines = lines[lines.index('{') :]
        data = json.loads(''.join(lines[lines.index('{') :]))
        return {
            'formulae': {
                x[self.name_key()]: x for x in data.get('formulae', [])
            },
            'casks': {x[self.token_key()]: x for x in data.get('casks', [])},
        }

    def get_each_type_info(self, package_type: str) -> dict[str, Any]:
        packages = self.get_packages(package_type)
        while True:
            info = self.get_json_info(
                f'--{package_type} {" ".join(packages)}',
                False,
            )

            if isinstance(info, dict):
                return info[package_type]

            updated = 0
            for line in info:
                err_msg = line.replace('Error: ', '').replace('::error::', '')
                package = ''
                if 'requires at least a URL' in err_msg:
                    # Remove package from list if it has no URL
                    # https://github.com/hashicorp/homebrew-tap/issues/258
                    package = err_msg.split()[0].strip(':').lower()
                elif 'No available' in err_msg:
                    # Remove non-package
                    # This can be found in hashicorp/tap
                    # "util" directory is misunderstood as a package
                    # Some formulae files under more than 2 directories are found as formulae
                    # but not inofo is available
                    package = (
                        err_msg.split('with the name ')[1]
                        .split('".')[0]
                        .strip('"')
                        .lower()
                    )
                if package:
                    packages_keep = packages.copy()
                    for p in packages:
                        pl = p.lower()
                        if (
                            pl == package
                            or pl.split('/')[-1] == package
                            or pl.split('/')[-1] == package.split('/')[-1]
                        ):
                            packages_keep.remove(p)
                            updated = 1
                    packages = packages_keep
            if updated:
                continue
            msg = f'Failed to get info of all {package_type}.\n\n'
            msg += '\n'.join(info)
            raise RuntimeError(msg)

    def get_all_info(self) -> dict[str, dict[str, Any]]:
        """Get info of all available brew package."""
        if 'formulae' in self.all_info and 'casks' in self.all_info:
            return self.all_info

        info = self.get_json_info('--eval-all', False)
        if isinstance(info, dict):
            self.all_info = info
            return self.all_info

        self.all_info = {
            'formulae': self.get_each_type_info('formulae'),
            'casks': self.get_each_type_info('casks'),
        }
        return self.all_info

    def get_info(self) -> dict[str, Any]:
        """Get info of installed brew package."""
        if 'formulae' in self.info and 'casks' in self.info:
            return self.info

        self.info = cast(
            'dict[str, Any]', self.get_json_info('--installed', True)
        )
        return self.info

    def get_formula_list(self) -> list[str]:
        info = self.get_info()
        return list(info['formulae'].keys())

    def get_cask_list(self) -> list[str]:
        info = self.get_info()
        return list(info['casks'].keys())

    def flatten_dict(self, orig_dict: dict[str, Any]) -> dict[str, Any]:
        flat_dict = {}
        for k, v in orig_dict.items():
            if isinstance(v, dict):
                flat_dict.update(self.flatten_dict(v))
            else:
                flat_dict[k] = v
        return flat_dict

    def get_aliases(
        self, package_type: str, flat: bool = False
    ) -> dict[str, Any]:
        if package_type in self.aliases:
            return (
                self.flatten_dict(self.aliases[package_type])
                if flat
                else self.aliases[package_type]
            )

        self.aliases = {package_type: {}}
        info = self.get_info()
        oldnames = 'oldnames' if package_type == 'formulae' else 'old_tokens'
        key = (
            self.name_key() if package_type == 'formulae' else self.token_key()
        )
        for package in info[package_type].values():
            tap = package['tap']
            for o in package.get(oldnames, []):
                self.aliases[package_type][tap] = self.aliases[
                    package_type
                ].get(tap, {})
                self.aliases[package_type][tap][o] = package[key]
            for a in package.get('aliases', []):
                self.aliases[package_type][tap] = self.aliases[
                    package_type
                ].get(tap, {})
                self.aliases[package_type][tap][a] = package[key]
        return (
            self.flatten_dict(self.aliases[package_type])
            if flat
            else self.aliases[package_type]
        )

    def get_formula_aliases(self, flat: bool = False) -> dict[str, Any]:
        return self.get_aliases('formulae', flat)

    def get_cask_aliases(self, flat: bool = False) -> dict[str, Any]:
        return self.get_aliases('casks', flat)

    def get_installed(self, package: str) -> dict[str, Any]:
        """Get installed version of brew package."""
        installed = {}
        package_info = self.get_info()['formulae'][package]

        if (version := package_info['linked_keg']) is None:
            version = package_info['installed'][-1]['version']

        if version != '':
            for i in package_info['installed']:
                if i['version'].replace('.reinstall', '') == version:
                    installed = i
                    break
        return installed

    def get_option(self, package: str) -> str:
        """Get install options from brew info."""
        opt = ''
        if used_options := self.get_installed(package).get('used_options', []):
            opt = ' ' + ' '.join(used_options)
        if version := self.get_installed(package).get('version', None):
            info = self.get_info()['formulae'][package]

            for k, v in info.get('versions', {}).items():
                if version == v and k != 'stable':
                    if k == 'head':
                        opt += ' --HEAD'
                    else:
                        opt += ' --' + k
        return opt

    def get_tap_packs(
        self,
        tap: str,
        alias: bool = False,
    ) -> dict[str, list[str]]:
        if self.taps is None:
            _, lines = self.proc(
                cmd='brew tap-info --json --installed',
                print_cmd=False,
                print_out=False,
                exit_on_err=True,
                separate_err=True,
            )
            lines = lines[lines.index('[') :]
            data = json.loads(''.join(lines))
            self.taps = {x['name']: x for x in data}

        packs = {
            'formulae': self.taps[tap]['formula_names'],
            'casks': self.taps[tap]['cask_tokens'],
        }
        if not self.opt['full_name']:
            packs = {
                'formulae': [x.split('/')[-1] for x in packs['formulae']],
                'casks': [x.split('/')[-1] for x in packs['casks']],
            }

        if alias:
            packs['formulae'] += list(
                self.get_formula_aliases().get(tap, {}).keys(),
            )
            packs['casks'] += list(self.get_cask_aliases().get(tap, {}).keys())
        return packs

    def get_leaves(self, on_request: bool = False) -> list[str]:
        if on_request:
            leaves_list = self.leaves_list_on_request
        else:
            leaves_list = self.leaves_list

        if leaves_list is not None:
            return leaves_list

        cmd = 'brew leaves'
        if on_request:
            cmd += ' --installed-on-request'
        _, leaves_list = self.proc(
            cmd,
            print_cmd=False,
            print_out=False,
            separate_err=True,
            print_err=False,
        )
        if not self.opt['full_name']:
            leaves_list = [x.split('/')[-1] for x in leaves_list]
        if on_request:
            self.leaves_list_on_request = leaves_list
        else:
            self.leaves_list = leaves_list
        return leaves_list

    def get_full_name(self, package: str) -> str:
        """Get full name (user/tap/package) of a package."""
        info = self.get_info()
        tap = ''
        if package in info['formulae']:
            tap = info['formulae'][package]['tap']
        elif package in info['casks']:
            tap = info['casks'][package]['tap']
        if not tap or tap in [self.opt['core_repo'], self.opt['cask_repo']]:
            return package
        return f'{tap}/{package}'


@dataclass
class BrewInfo:
    """Homebrew information storage."""

    helper: BrewHelper
    file: Path = field(default_factory=lambda: Path())

    def __post_init__(self) -> None:
        self.log = logging.getLogger(__name__)

        self.brew_opt_input: dict[str, str] = {}
        self.brew_input: list[str] = []
        self.tap_input: list[str] = []
        self.cask_input: list[str] = []
        self.appstore_input: list[str] = []
        self.whalebrew_input: list[str] = []
        self.vscode_input: list[str] = []
        self.cursor_input: list[str] = []
        self.codium_input: list[str] = []
        self.main_input: list[str] = []
        self.file_input: list[str] = []
        self.before_input: list[str] = []
        self.after_input: list[str] = []
        self.cmd_input: list[str] = []
        self.cask_args_input: dict[str, str] = {}

        self.brew_opt_list: dict[str, str] = {}
        self.brew_list: list[str] = []
        self.brew_full_list: list[str] = []
        self.tap_list: list[str] = []
        self.cask_list: list[str] = []
        self.appstore_list: list[str] = []
        self.whalebrew_list: list[str] = []
        self.vscode_list: list[str] = []
        self.cursor_list: list[str] = []
        self.codium_list: list[str] = []
        self.main_list: list[str] = []
        self.file_list: list[str] = []
        self.cask_nocask_list: list[str] = []

        self.lists: dict[str, list[str]] = {
            'brew_input': self.brew_input,
            'tap_input': self.tap_input,
            'cask_input': self.cask_input,
            'appstore_input': self.appstore_input,
            'whalebrew_input': self.whalebrew_input,
            'vscode_input': self.vscode_input,
            'cursor_input': self.cursor_input,
            'codium_input': self.codium_input,
            'main_input': self.main_input,
            'file_input': self.file_input,
            'before_input': self.before_input,
            'after_input': self.after_input,
            'cmd_input': self.cmd_input,
            'brew_list': self.brew_list,
            'brew_full_list': self.brew_full_list,
            'tap_list': self.tap_list,
            'cask_list': self.cask_list,
            'cask_nocask_list': self.cask_nocask_list,
            'appstore_list': self.appstore_list,
            'whalebrew_list': self.whalebrew_list,
            'vscode_list': self.vscode_list,
            'cursor_list': self.cursor_list,
            'codium_list': self.codium_list,
            'main_list': self.main_list,
            'file_list': self.file_list,
        }
        self.dicts: dict[str, dict[str, str]] = {
            'brew_opt_input': self.brew_opt_input,
            'cask_args_input': self.cask_args_input,
            'brew_opt_list': self.brew_opt_list,
        }

    def get_dir(self) -> Path:
        return self.file.parent

    def check_file(self) -> bool:
        return self.file.exists()

    def check_dir(self) -> bool:
        return self.get_dir().exists()

    def clear_input(self) -> None:
        self.brew_opt_input.clear()

        del self.brew_input[:]
        del self.tap_input[:]
        del self.cask_input[:]
        del self.appstore_input[:]
        del self.whalebrew_input[:]
        del self.vscode_input[:]
        del self.cursor_input[:]
        del self.codium_input[:]
        del self.main_input[:]
        del self.file_input[:]

        del self.before_input[:]
        del self.after_input[:]
        del self.cmd_input[:]

        self.cask_args_input.clear()

    def clear_list(self) -> None:
        self.brew_opt_list.clear()

        del self.brew_list[:]
        del self.brew_full_list[:]
        del self.tap_list[:]
        del self.cask_list[:]
        del self.cask_nocask_list[:]
        del self.appstore_list[:]
        del self.whalebrew_list[:]
        del self.vscode_list[:]
        del self.cursor_list[:]
        del self.codium_list[:]
        del self.main_list[:]
        del self.file_list[:]

    def clear(self) -> None:
        self.clear_input()
        self.clear_list()

    def input_to_list(self) -> None:
        # Keep brew_opt made from brew command and ignore brew_opt_input to
        # keep actual options
        brew_opt = self.brew_opt_input.copy()
        brew_opt.update(self.brew_opt_list)
        for k, v in self.brew_opt_input.items():
            if k in brew_opt and v != brew_opt[k]:
                self.log.warning(
                    f'Installed options for "{k}" ("{brew_opt[k]}") are '
                    f'different from options in Brewfile ("{v}"). '
                    f'Replace them by installed ones.'
                )

        self.clear_list()
        self.brew_opt_list.update(brew_opt)
        self.brew_list.extend(self.brew_input)
        self.tap_list.extend(self.tap_input)
        self.cask_list.extend(self.cask_input)
        self.appstore_list.extend(self.appstore_input)
        self.whalebrew_list.extend(self.whalebrew_input)
        self.vscode_list.extend(self.vscode_input)
        self.cursor_list.extend(self.cursor_input)
        self.codium_list.extend(self.codium_input)
        self.main_list.extend(self.main_input)
        self.file_list.extend(self.file_input)

    def sort(self) -> None:
        core_tap = []
        cask_tap = []
        brew_taps = []
        other_taps = []
        for t in self.tap_list:
            if t == self.helper.opt['core_repo']:
                core_tap.append(t)
            elif t == self.helper.opt['cask_repo']:
                cask_tap.append(t)
            elif t.startswith(self.helper.opt['homebrew_tap_prefix']):
                brew_taps.append(t)
            else:
                other_taps.append(t)
        brew_taps.sort()
        other_taps.sort()
        self.tap_list = core_tap + cask_tap + brew_taps + other_taps

        self.brew_list.sort()
        self.brew_full_list.sort()
        self.cask_list.sort()
        self.main_list.sort()
        self.file_list.sort()
        self.cask_nocask_list.sort()

        self.appstore_list.sort(
            key=lambda x: (
                x.split()[1].lower() if len(x.split()) > 1 else x.split()[0]
            ),
        )

        self.whalebrew_list.sort()
        self.vscode_list.sort()
        self.cursor_list.sort()
        self.codium_list.sort()

    def get_list(self, name: str) -> list[str]:
        return copy.deepcopy(self.lists[name])

    def get_dict(self, name: str) -> dict[str, str]:
        return copy.deepcopy(self.dicts[name])

    def get_files(self) -> dict[str, list[str]]:
        self.read()
        files = {'main': self.get_list('main_input')}
        files.update({'ext': self.get_list('file_input')})
        return files

    def remove(self, name: str, package: str) -> None:
        if name in self.lists:
            self.lists[name].remove(package)
        else:
            del self.dicts[name][package]

    def set_list_val(self, name: str, val: list[str]) -> None:
        collection = self.lists[name]
        del collection[:]
        collection.extend(val)

    def set_dict_val(self, name: str, val: dict[str, str]) -> None:
        collection = self.dicts[name]
        collection.clear()
        collection.update(val)

    def add_to_list(self, name: str, val: list[str]) -> None:
        collection = self.lists[name]
        collection.extend([x for x in val if x not in collection])

    def add_to_dict(self, name: str, val: dict[str, Any]) -> None:
        collection = self.dicts[name]
        collection.update(val)

    def read(self) -> None:
        self.clear_input()

        if not self.file.exists():
            return
        with Path(self.file).open() as f:
            lines = f.readlines()
            is_ignore = False
            for line in lines:
                if re.match('# *BREWFILE_ENDIGNORE', line):
                    is_ignore = False
                if re.match('# *BREWFILE_IGNORE', line):
                    is_ignore = True
                if is_ignore:
                    continue
                if (
                    re.match(' *$', line) is not None
                    or re.match(' *#', line) is not None
                ):
                    continue
                args = (
                    line.replace("'", '')
                    .replace('"', '')
                    .replace(',', ' ')
                    .replace('[', '')
                    .replace(']', '')
                    .split()
                )
                cmd = args[0]
                p = args[1] if len(args) > 1 else ''
                if len(args) > 2 and p in ['tap', 'cask']:
                    args.pop(0)
                    cmd = args[0]
                    p = args[1]
                    if not self.helper.opt.get('form'):
                        self.helper.opt['form'] = 'cmd'
                if (
                    len(args) > 2
                    and cmd in ['brew', 'cask']
                    and p == 'install'
                ):
                    args.pop(1)
                    p = args[1]
                    if not self.helper.opt.get('form'):
                        self.helper.opt['form'] = 'cmd'

                if len(args) > 2:
                    if args[2] == 'args:':
                        opt = (
                            ' '
                            + ' '.join(['--' + x for x in args[3:]]).strip()
                        )
                        if not self.helper.opt.get('form'):
                            self.helper.opt['form'] = 'bundle'
                    else:
                        opt = ' ' + ' '.join(args[2:]).strip()
                else:
                    opt = ''
                excmd = ' '.join(line.split()[1:]).strip()

                if not self.helper.opt.get('form') and (
                    cmd in ['brew', 'cask', 'tap', 'tapall']
                    and ('"' in line or "'" in line)
                ):
                    self.helper.opt['form'] = 'bundle'

                cmd = cmd.lower()
                if cmd in ['brew', 'install']:
                    self.brew_input.append(p)
                    self.brew_opt_input[p] = opt
                elif cmd == 'tap':
                    self.tap_input.append(p)
                elif cmd == 'tapall':
                    _ = self.helper.proc(f'brew tap {p}')
                    self.tap_input.append(p)
                    tap_packs = self.helper.get_tap_packs(p)
                    for tp in tap_packs['formulae']:
                        self.brew_input.append(tp)
                        self.brew_opt_input[tp] = ''
                    if is_mac():
                        for tp in tap_packs['casks']:
                            self.cask_input.append(tp)
                elif cmd == 'cask':
                    self.cask_input.append(p)
                elif cmd == 'mas' and line.find(',') != -1:
                    if not self.helper.opt.get('form'):
                        self.helper.opt['form'] = 'bundle'
                    p = (
                        ' '.join(line.split(',')[0].split()[1:])
                        .strip("'")
                        .strip('"')
                    )
                    pid = line.split(',')[1].split()[1]
                    self.appstore_input.append(pid + ' ' + p)
                elif cmd in ['appstore', 'mas']:
                    self.appstore_input.append(
                        re.sub('^ *appstore *', '', line)
                        .strip()
                        .strip("'")
                        .strip('"'),
                    )
                elif cmd == 'whalebrew':
                    if p.split()[0] == 'install':
                        self.whalebrew_input.append(p.split()[1])
                    else:
                        self.whalebrew_input.append(p)
                elif cmd in ['vscode', 'code']:
                    if p.split()[0] == '--install-extension':
                        self.vscode_input.append(p.split()[1])
                    else:
                        self.vscode_input.append(p)
                elif cmd == 'cursor':
                    if p.split()[0] == '--install-extension':
                        self.cursor_input.append(p.split()[1])
                    else:
                        self.cursor_input.append(p)
                elif cmd in ['vscodium', 'codium']:
                    if p.split()[0] == '--install-extension':
                        self.codium_input.append(p.split()[1])
                    else:
                        self.codium_input.append(p)
                elif cmd == 'main':
                    self.main_input.append(p)
                    self.file_input.append(p)
                elif cmd in ['file', 'brewfile']:
                    self.file_input.append(p)
                elif cmd == 'before':
                    self.before_input.append(excmd)
                elif cmd == 'after':
                    self.after_input.append(excmd)
                elif cmd == 'cask_args':
                    if excmd.startswith('--'):
                        for arg in excmd.split():
                            if '=' in arg:
                                k, v = arg.split('=')
                            else:
                                k = arg
                                v = ''
                            k = k.strip('"\' ')
                            v = v.strip('"\' ')
                            self.cask_args_input[k] = v
                    else:
                        for arg in excmd.split(','):
                            k, v = arg.split(':')
                            k = k.strip('"\' ')
                            k = f'--{k}'
                            v = v.strip('"\' ')
                            if v == 'true':
                                v = ''
                            self.cask_args_input[k] = v
                else:
                    self.cmd_input.append(line.strip())

    def convert_option(self, opt: str) -> str:
        if opt != '' and self.helper.opt['form'] in ['brewdler', 'bundle']:
            opt = (
                ', args: ['
                + ', '.join(
                    ["'" + re.sub('^--', '', x) + "'" for x in opt.split()],
                )
                + ']'
            )
        return opt

    def packout(self, pack: str) -> str:
        """Get package name for output."""
        if self.helper.opt['form'] in ['brewdler', 'bundle']:
            return "'" + pack + "'"
        return pack

    def mas_pack(self, pack: str) -> str:
        if self.helper.opt['form'] in ['brewdler', 'bundle']:
            pack_split = pack.split()
            pid = pack_split[0]
            name = pack_split[1:]
            return "'" + ' '.join(name) + "', id: " + pid
        return pack

    def write(self) -> None:
        output_prefix = ''
        output = ''

        # comd base
        cmd_before = 'before '
        cmd_after = 'after '
        cmd_cask_args = 'cask_args '
        cmd_other = ''
        cmd_install = 'brew '
        cmd_tap = 'tap '
        cmd_cask = 'cask '
        cmd_cask_nocask = '#cask '
        cmd_appstore = 'appstore '
        cmd_whalebrew = 'whalebrew '
        cmd_vscode = 'vscode '
        cmd_cursor = 'cursor '
        cmd_codium = 'codium '
        cmd_main = 'main '
        cmd_file = 'file '
        if self.helper.opt['form'] in ['file', None]:
            pass
        elif self.helper.opt['form'] in ['brewdler', 'bundle']:
            cmd_before = '#before '
            cmd_after = '#after '
            cmd_cask_args = '#cask_args '
            cmd_other = '#'
            cmd_cask_nocask = '#cask '
            cmd_appstore = 'mas '
            cmd_whalebrew = 'whalebrew '
            cmd_vscode = 'vscode '
            cmd_cursor = 'cursor '
            cmd_codium = 'codium '
            cmd_main = '#main '
            cmd_file = '#file '
        elif self.helper.opt['form'] in ['command', 'cmd']:
            # Shebang for command format
            output_prefix += """#!/usr/bin/env bash

#BREWFILE_IGNORE
if ! which brew >& /dev/null;then
  brew_installed=0
  echo Homebrew is not installed!
  echo Install now...
  echo /bin/bash -c \\\"\\$\\(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh\\)\\\"
  /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)\"
  echo
fi
#BREWFILE_ENDIGNORE

"""

            cmd_before = ''
            cmd_after = ''
            cmd_other = ''
            cmd_install = 'brew install '
            cmd_tap = 'brew tap '
            cmd_cask = 'brew install '
            cmd_cask_nocask = '#brew install '
            cmd_appstore = 'mas install '
            cmd_whalebrew = 'whalebrew install '
            cmd_vscode = 'code --install-extension '
            cmd_cursor = 'cursor --install-extension '
            cmd_codium = 'codium --install-extension '
            cmd_main = '#main '
            cmd_file = '#file '
        else:
            msg = f'Invalid format: "{self.helper.opt["form"]}".\nUse "file", "brewdler", "bundle", "command" or "cmd".'
            raise ValueError(msg)

        # sort
        self.sort()

        # Before commands
        if self.before_input:
            output += '# Before commands\n'
            for c in self.before_input:
                output += cmd_before + c + '\n'

        # Cask args
        if self.cask_args_input:
            output += '\n# Cask args\n'
            delimiter = ''
            for k, v in self.cask_args_input.items():
                output += cmd_cask_args
                if self.helper.opt['form'] in ['brewdler', 'bundle']:
                    if v == '':
                        output += f'{delimiter}{k[2:]}: true'
                    else:
                        output += f'{delimiter}{k[2:]}: {v}'
                    delimiter = ', '
                else:
                    output += f'{delimiter}{k}'
                    if v != '':
                        output += f'={v}'
                    delimiter = ' '
            output += '\n'

        # Taps
        if self.tap_list:
            isfirst = True

            def first_tap_pack_write(
                isfirst: bool,
                isfirst_pack: bool,
                tap: str,
                cmd_tap: str,
            ) -> str:
                output = ''
                if isfirst:
                    output += '\n# tap repositories and their packages\n'
                if isfirst_pack:
                    output += '\n' + cmd_tap + self.packout(tap) + '\n'
                return output

            for t in self.tap_list:
                isfirst_pack = True

                tap_packs = self.helper.get_tap_packs(t, alias=True)

                if not self.helper.opt['caskonly']:
                    output += first_tap_pack_write(
                        isfirst,
                        isfirst_pack,
                        t,
                        cmd_tap,
                    )
                    isfirst = isfirst_pack = False

                    for p in self.brew_list[:]:
                        if p in tap_packs['formulae']:
                            pack = self.packout(p) + self.convert_option(
                                self.brew_opt_list[p],
                            )
                            output += cmd_install + pack + '\n'
                            self.brew_list.remove(p)
                            del self.brew_opt_list[p]
                if not is_mac():
                    continue
                tap_casks = tap_packs['casks']
                for p in self.cask_list[:]:
                    if p in tap_casks:
                        output += first_tap_pack_write(
                            isfirst,
                            isfirst_pack,
                            t,
                            cmd_tap,
                        )
                        isfirst = isfirst_pack = False
                        output += cmd_cask + self.packout(p) + '\n'
                        self.cask_list.remove(p)

        # Brew packages
        if not self.helper.opt['caskonly'] and self.brew_list:
            output += '\n# Other Homebrew packages\n'
            for p in self.brew_list:
                pack = self.packout(p) + self.convert_option(
                    self.brew_opt_list[p],
                )
                output += cmd_install + pack + '\n'

        # Casks
        if is_mac() and self.cask_list:
            output += '\n# Other Cask applications\n'
            for c in self.cask_list:
                output += cmd_cask + self.packout(c) + '\n'

        # Installed by cask, but cask files were not found...
        if is_mac() and self.cask_nocask_list:
            output += '\n# Below applications were installed by Cask,\n'
            output += '# but do not have corresponding casks.\n\n'
            for c in self.cask_nocask_list:
                output += cmd_cask_nocask + self.packout(c) + '\n'

        # App Store applications
        if is_mac() and self.helper.opt['appstore'] and self.appstore_list:
            output += '\n# App Store applications\n'
            for a in self.appstore_list:
                output += cmd_appstore + self.mas_pack(a) + '\n'

        # Whalebrew images
        if self.helper.opt['whalebrew'] and self.whalebrew_list:
            output += '\n# Whalebrew images\n'
            for i in self.whalebrew_list:
                output += cmd_whalebrew + self.packout(i) + '\n'

        # VSCode extensions
        if self.helper.opt['vscode'] and self.vscode_list:
            output += '\n# VSCode extensions\n'
            for e in self.vscode_list:
                output += cmd_vscode + self.packout(e) + '\n'

        # Cursor extensions
        if self.helper.opt['cursor'] and self.cursor_list:
            output += '\n# Cursor extensions\n'
            for e in self.cursor_list:
                output += cmd_cursor + self.packout(e) + '\n'

        # VSCodium extensions
        if self.helper.opt['codium'] and self.codium_list:
            output += '\n# VSCodium extensions\n'
            for e in self.codium_list:
                output += cmd_codium + self.packout(e) + '\n'

        # Main file
        if self.main_list:
            output += '\n# Main file\n'
            for f in self.main_list:
                output += cmd_main + self.packout(f) + '\n'

        # Additional files
        if len(self.file_list) > len(self.main_list):
            output += '\n# Additional files\n'
            for f in self.file_list:
                if f not in self.main_list:
                    output += cmd_file + self.packout(f) + '\n'

        # Other commands
        if self.cmd_input:
            output += '\n# Other commands\n'
            for c in self.cmd_input:
                output += cmd_other + c + '\n'

        # After commands
        if self.after_input:
            output += '\n# After commands\n'
            for c in self.after_input:
                output += cmd_after + c + '\n'

        # Write to Brewfile
        if output:
            output = output_prefix + output
            self.get_dir().mkdir(parents=True, exist_ok=True)
            with Path(self.file).open('w') as fout:
                fout.write(output)
            self.log.debug(output)

        # Change permission for exe/normal file
        if self.helper.opt['form'] in ['command', 'cmd']:
            _ = self.helper.proc(
                f'chmod 755 {self.file}',
                print_cmd=False,
                print_out=False,
                exit_on_err=False,
            )
        else:
            _ = self.helper.proc(
                f'chmod 644 {self.file}',
                print_cmd=False,
                print_out=False,
                exit_on_err=False,
            )


CaskInfo = dict[str, tuple[str, str]]
CaskListInfo = dict[str, list[tuple[str, str]]]


@dataclass
class BrewFile:
    """Main class of Brew-file."""

    opt: dict[str, Any] = field(default_factory=dict)

    def __post_init__(self) -> None:
        self.log = logging.getLogger(__name__)

        # Make helper
        self.helper = BrewHelper(self.opt)

        # Check Homebrew
        self.check_brew_cmd()

        # Set full opt
        for k, v in self.default_opt().items():
            if k not in self.opt:
                self.opt[k] = v

        # Set other initial variables
        self.int_opts: list[str] = []
        self.float_opts: list[str] = []

        # fix up opt
        self.set_args()

    def get_input_path(self) -> Path:
        input_path = None
        xdg_config_home = os.getenv('XDG_CONFIG_HOME')
        if xdg_config_home is not None:
            input_path = Path(xdg_config_home) / 'brewfile/Brewfile'
            if input_path.is_file():
                return input_path
        home_config = Path(os.environ['HOME']) / '.config/brewfile/Brewfile'
        if home_config.is_file():
            return home_config
        if input_path is None:
            input_path = home_config

        home_brewfile = Path(os.environ['HOME']) / '/.brewfile/Brewfile'
        if home_brewfile.is_file():
            return home_brewfile
        return input_path

    def parse_env_opts(
        self,
        env_var: str,
        base_opts: dict[str, Any] | None = None,
    ) -> dict[str, str]:
        """Return a dictionary parsed from an environment variable."""
        opts: dict[str, Any] = {}
        if base_opts is not None:
            opts.update(base_opts)

        env_opts = os.getenv(env_var, None)
        if env_opts:
            user_opts = dict(
                pair.partition('=')[::2] for pair in env_opts.split()
            )

            if user_opts:
                opts.update(user_opts)
            else:
                self.log.warning(
                    '{env_var}: "{env_opts}" is not a proper format.',
                )
                self.log.warning('Ignoring the value.\n')
        return opts

    def default_opt(self) -> dict[str, Any]:
        opt: dict[str, Any] = {}
        opt['verbose'] = os.getenv('HOMEBREW_BREWFILE_VERBOSE', 'info')
        opt['command'] = ''
        opt['input'] = Path(os.getenv('HOMEBREW_BREWFILE', ''))
        if not opt['input'].name:
            opt['input'] = self.get_input_path()
        opt['backup'] = os.getenv('HOMEBREW_BREWFILE_BACKUP', '')
        opt['form'] = None
        opt['leaves'] = to_bool(os.getenv('HOMEBREW_BREWFILE_LEAVES', ''))
        opt['on_request'] = to_bool(
            os.getenv('HOMEBREW_BREWFILE_ON_REQUEST', ''),
        )
        opt['top_packages'] = os.getenv('HOMEBREW_BREWFILE_TOP_PACKAGES', '')
        opt['fetch_head'] = to_bool(
            os.getenv('HOMEBREW_BREWFILE_FETCH_HEAD', ''),
        )
        opt['repo'] = ''
        opt['no_repo'] = False
        opt['noupgradeatupdate'] = False
        opt['link'] = True
        opt['caskonly'] = False
        opt['dryrun'] = False
        opt['initialized'] = False
        opt['homebrew_tap_prefix'] = 'homebrew/'
        opt['core_repo'] = f'{opt["homebrew_tap_prefix"]}core'
        opt['cask_repo'] = f'{opt["homebrew_tap_prefix"]}cask'
        opt['reattach_formula'] = 'reattach-to-user-namespace'
        opt['mas_formula'] = 'mas'
        opt['whalebrew_formula'] = 'whalebrew'
        opt['vscode_formula'] = 'visual-studio-code'
        opt['cursor_formula'] = 'cursor'
        opt['codium_formula'] = 'vscodium'
        opt['my_editor'] = os.getenv(
            'HOMEBREW_BREWFILE_EDITOR',
            os.getenv('EDITOR', 'vim'),
        )
        opt['brew_cmd'] = ''
        opt['mas_cmd'] = 'mas'
        opt['is_mas_cmd'] = 0
        opt['mas_cmd_installed'] = False
        opt['reattach_cmd_installed'] = False
        opt['whalebrew_cmd'] = 'whalebrew'
        opt['is_whalebrew_cmd'] = 0
        opt['whalebrew_cmd_installed'] = False
        opt['vscode_cmd'] = 'code'
        opt['is_vscode_cmd'] = 0
        opt['vscode_cmd_installed'] = False
        opt['cursor_cmd'] = 'cursor'
        opt['is_cursor_cmd'] = 0
        opt['cursor_cmd_installed'] = False
        opt['codium_cmd'] = 'codium'
        opt['is_codium_cmd'] = 0
        opt['codium_cmd_installed'] = False
        opt['docker_running'] = 0
        opt['args'] = []
        opt['yn'] = False
        opt['brew_packages'] = ''
        opt['homebrew_ruby'] = False

        # Check Homebrew variables
        # Boolean HOMEBREW variable should be True if other than empty is set, including '0'
        opt['api'] = not os.getenv('HOMEBREW_NO_INSTALL_FROM_API', '')
        opt['cache'] = self.helper.brew_val('cache')
        opt['caskroom'] = self.helper.brew_val('prefix') + '/Caskroom'
        cask_opts = self.parse_env_opts(
            'HOMEBREW_CASK_OPTS',
            {'--appdir': '', '--fontdir': ''},
        )
        opt['appdir'] = (
            cask_opts['--appdir'].rstrip('/')
            if cask_opts['--appdir'] != ''
            else os.environ['HOME'] + '/Applications'
        )
        opt['appdirlist'] = [
            '/Applications',
            os.environ['HOME'] + '/Applications',
        ]
        if opt['appdir'].rstrip('/') not in opt['appdirlist']:
            opt['appdirlist'].append(opt['appdir'])
        opt['appdirlist'] += [
            x.rstrip('/') + '/Utilities' for x in opt['appdirlist']
        ]
        opt['appdirlist'] = [x for x in opt['appdirlist'] if Path(x).is_dir()]
        # fontdir may be used for application search, too
        opt['fontdir'] = cask_opts['--fontdir']

        opt['appstore'] = to_num(os.getenv('HOMEBREW_BREWFILE_APPSTORE', '-1'))
        opt['no_appstore'] = False
        opt['full_name'] = to_bool(
            os.getenv('HOMEBREW_BREWFILE_FULL_NAME', '')
        )
        opt['all_files'] = False

        opt['whalebrew'] = to_num(
            os.getenv('HOMEBREW_BREWFILE_WHALEBREW', '0'),
        )
        opt['vscode'] = to_num(os.getenv('HOMEBREW_BREWFILE_VSCODE', '0'))
        opt['cursor'] = to_num(os.getenv('HOMEBREW_BREWFILE_CURSOR', '0'))
        opt['codium'] = to_num(os.getenv('HOMEBREW_BREWFILE_CODIUM', '0'))

        opt['read'] = False

        return opt

    def set_input(self, file: str | Path) -> None:
        self.opt['input'] = Path(file)
        self.brewinfo = BrewInfo(self.helper, self.opt['input'])
        self.brewinfo_ext: list[BrewInfo] = []
        self.brewinfo_main = self.brewinfo

    def banner(self, text: str, debug_out: bool = False) -> None:
        width = 0
        for line in text.split('\n'):
            width = max(width, len(line))
        output = f'\n{"#" * width}\n{text}\n{"#" * width}\n'
        if debug_out:
            self.log.debug(output)
        else:
            self.log.info(output)

    @dataclass
    class DryrunBanner:
        """Dryrun banner context manager."""

        brewfile: BrewFile

        def __enter__(self) -> None:
            if self.brewfile.opt['dryrun']:
                self.brewfile.banner('# This is dry run.')

        def __exit__(
            self,
            exc_type: type[BaseException] | None,
            exc_value: BaseException | None,
            traceback: TracebackType | None,
        ) -> None:
            if self.brewfile.opt['dryrun']:
                self.brewfile.banner('# This is dry run.')

    def set_verbose(self, verbose: str | None = None) -> None:
        if verbose is None:
            self.opt['verbose'] = os.getenv(
                'HOMEBREW_BREWFILE_VERBOSE',
                'info',
            )
        else:
            self.opt['verbose'] = verbose
        # Keep compatibility with old verbose
        if self.opt['verbose'] == '0':
            self.opt['verbose'] = 'debug'
        elif self.opt['verbose'] == '1':
            self.opt['verbose'] = 'info'
        elif self.opt['verbose'] == '2':
            self.opt['verbose'] = 'error'

        if self.log.parent and self.log.parent.name != 'root':
            self.log.parent.setLevel(
                getattr(logging, self.opt['verbose'].upper()),
            )
        else:
            self.log.setLevel(getattr(logging, self.opt['verbose'].upper()))

    def set_args(self, **kw: str) -> None:
        """Set arguments."""
        self.opt.update(kw)

        self.set_verbose(self.opt.get('verbose', None))
        for k in self.int_opts:
            self.opt[k] = int(self.opt[k])
        for k in self.float_opts:
            self.opt[k] = float(self.opt[k])

        # fix appstore option
        appstore = 1
        if self.opt['appstore'] != -1:
            appstore = self.opt['appstore']
        elif self.opt['no_appstore']:
            appstore = 0
        self.opt['appstore'] = to_num(appstore)

        self.set_input(self.opt['input'])

    def ask_yn(self, question: str) -> bool:
        """Ask yes/no question."""
        if self.opt['yn']:
            self.log.info(f'{question} [y/n]: y')
            return True

        yes = ['yes', 'y', '']
        no = ['no', 'n']

        yn = input(f'{question} [y/n]: ').lower()
        while True:
            if yn in yes:
                return True
            if yn in no:
                return False
            yn = input('Answer with yes (y) or no (n): ').lower()

    def read_all(self, force: bool = False) -> None:
        if not force and self.opt['read']:
            return
        self.brewinfo_ext = [self.brewinfo]
        main = self.read(self.brewinfo, is_main=True)
        if not main:
            msg = 'Cannot find main Brewfile.'
            raise RuntimeError(msg)
        self.brewinfo_main = main
        self.brewinfo_ext.remove(self.brewinfo_main)
        for cmd in [
            'mas',
            'reattach',
            'whalebrew',
            'vscode',
            'cursor',
            'codium',
        ]:
            if self.opt[f'{cmd}_cmd_installed']:
                p = Path(self.opt[f'{cmd}_formula']).name
                if p not in self.get_list('brew_input'):
                    self.brewinfo_main.brew_input.append(p)
                    self.brewinfo_main.brew_opt_input[p] = ''
        self.opt['read'] = True

    def read(
        self,
        brewinfo: BrewInfo,
        is_main: bool = False,
    ) -> BrewInfo | None:
        main = brewinfo if is_main else None
        files = brewinfo.get_files()
        for f in files['ext']:
            is_next_main = f in files['main']
            path = expandpath(f)
            if path.is_absolute():
                b = BrewInfo(self.helper, path)
            else:
                b = BrewInfo(self.helper, brewinfo.get_dir() / path)
            self.brewinfo_ext.append(b)
            if main is not None and is_next_main:
                main = b
                main_tmp = self.read(b, True)
            else:
                main_tmp = self.read(b, False)
            if main_tmp is not None:
                main = main_tmp
        return main

    def list_to_main(self) -> None:
        if self.brewinfo == self.brewinfo_main:
            return
        self.brewinfo_main.add_to_list('brew_list', self.brewinfo.brew_list)
        self.brewinfo_main.add_to_list(
            'brew_full_list',
            self.brewinfo.brew_list,
        )
        self.brewinfo_main.add_to_list('tap_list', self.brewinfo.tap_list)
        self.brewinfo_main.add_to_list('cask_list', self.brewinfo.cask_list)
        self.brewinfo_main.add_to_list(
            'cask_nocask_list',
            self.brewinfo.cask_nocask_list,
        )
        self.brewinfo_main.add_to_list(
            'appstore_list',
            self.brewinfo.appstore_list,
        )
        self.brewinfo_main.add_to_list(
            'whalebrew_list',
            self.brewinfo.whalebrew_list,
        )
        self.brewinfo_main.add_to_list(
            'vscode_list',
            self.brewinfo.vscode_list,
        )
        self.brewinfo_main.add_to_list(
            'cursor_list',
            self.brewinfo.cursor_list,
        )
        self.brewinfo_main.add_to_list(
            'codium_list',
            self.brewinfo.codium_list,
        )
        self.brewinfo_main.add_to_dict(
            'brew_opt_list',
            self.brewinfo.brew_opt_list,
        )

    def input_to_list(self, only_ext: bool = False) -> None:
        if not only_ext:
            self.brewinfo_main.input_to_list()
        for b in self.brewinfo_ext:
            b.input_to_list()

    def write(self, debug_out: bool = False) -> None:
        self.banner(
            f'# Initialize {self.brewinfo_main.file}',
            debug_out=debug_out,
        )
        self.brewinfo_main.write()
        for b in self.brewinfo_ext:
            self.banner(f'# Initialize {b.file}', debug_out=debug_out)
            b.write()

    def get_list(self, name: str, only_ext: bool = False) -> set[str]:
        list_copy = [] if only_ext else self.brewinfo_main.get_list(name)
        for b in self.brewinfo_ext:
            list_copy += b.get_list(name)
        return set(list_copy)

    def get_dict(self, name: str, only_ext: bool = False) -> dict[str, str]:
        dict_copy = {} if only_ext else self.brewinfo_main.get_dict(name)
        for b in self.brewinfo_ext:
            dict_copy.update(b.get_dict(name))
        return dict_copy

    def get_non_alias_input(self, package_type: str) -> set[str]:
        if package_type == 'formulae':
            list_name = 'brew_input'
        elif package_type == 'casks':
            list_name = 'cask_input'
        aliases = self.helper.get_aliases(package_type, flat=True)
        packages = []
        for p in self.get_list(list_name):
            if p in aliases:
                packages.append(aliases[p])
            else:
                packages.append(p)
        return set(packages)

    def remove_pack(self, name: str, package: str) -> None:
        if package in self.brewinfo_main.get_list(name):
            self.brewinfo_main.remove(name, package)
        else:
            for b in self.brewinfo_ext:
                if package in b.get_list(name):
                    b.remove(name, package)

    def repo_name(self) -> str:
        return self.opt['repo'].split('/')[-1].split('.git')[0]

    def user_name(self) -> str:
        user = ''
        repo_split = self.opt['repo'].split('/')
        if len(repo_split) > 1:
            user = repo_split[-2].split(':')[-1]
        if not user:
            _, lines = self.helper.proc(
                'git config --get github.user',
                print_cmd=False,
                print_out=False,
                exit_on_err=False,
                separate_err=False,
            )
            if lines:
                user = lines[0]
            else:
                _, lines = self.helper.proc(
                    'git config --get user.name',
                    print_cmd=False,
                    print_out=False,
                    exit_on_err=False,
                    separate_err=False,
                )
                user = lines[0] if lines else ''
            if not user:
                msg = 'Can not find git (github) user name'
                raise RuntimeError(msg)
        return user

    def input_dir(self) -> Path:
        return self.opt['input'].parent

    def input_file(self) -> str:
        return self.opt['input'].name

    def repo_file(self) -> Path:
        """Return the Brewfile path for the repository."""
        return Path(
            self.input_dir(),
            self.user_name() + '_' + self.repo_name(),
            self.input_file(),
        )

    def init_repo(self) -> None:
        dirname = Path(self.brewinfo.get_dir())
        _, branches = self.helper.proc(
            'git branch',
            print_cmd=False,
            print_out=False,
            exit_on_err=True,
            separate_err=True,
            cwd=dirname,
        )
        if branches:
            return

        self.log.info('Initialize the repository with README.md/Brewfile.')
        readme = dirname / 'README.md'
        if not readme.exists():
            with Path(readme).open('w') as f:
                f.write(
                    '# ' + self.repo_name() + '\n\n'
                    'Package list for [homebrew](http://brew.sh/).\n\n'
                    'Managed by '
                    '[homebrew-file](https://github.com/rcmdnk/homebrew-file).',
                )
        self.brewinfo.file.touch()

        if self.check_gitconfig():
            _ = self.helper.proc('git add -A', cwd=dirname)
            _ = self.helper.proc(
                ['git', 'commit', '-m', '"Prepared by ' + __prog__ + '"'],
                cwd=dirname,
            )
            _, lines = self.helper.proc(
                'git branch --show-current',
                cwd=dirname,
                exit_on_err=False,
            )
            branch = lines[0]
            self.helper.proc(
                f'git push -u origin {branch}',
                cwd=dirname,
            )

    def clone_repo(self, exit_on_err: bool = True) -> bool:
        ret, _ = self.helper.proc(
            f"git clone {self.opt['repo']} '{self.brewinfo.get_dir()}'",
            print_cmd=True,
            print_out=True,
            exit_on_err=False,
        )
        if ret != 0:
            if exit_on_err:
                msg = (
                    f'Can not clone {self.opt["repo"]}.\n'
                    f'please check the repository, or reset with\n'
                    f'    $ {__prog__} set_repo'
                )
                raise RuntimeError(msg)
            return False
        self.init_repo()
        return True

    def check_github_repo(self) -> None:
        """Check GitHub repository."""
        # Check if the repository already exists or not.
        if self.clone_repo(exit_on_err=False):
            return

        # Create new repository #
        msg = (
            f"GitHub repository: {self.user_name()}/{self.repo_name()} doesn't exist.\n"
            'Please create the repository first, then try again'
        )
        raise RuntimeError(msg)

    def check_local_repo(self) -> None:
        dirname = self.opt['repo'].replace('file://', '')
        Path(dirname).mkdir(parents=True, exist_ok=True)
        _ = self.helper.proc('git init', cwd=dirname)
        _ = self.helper.proc(
            'git config --local receive.denyCurrentBranch updateInstead',
            cwd=dirname,
        )
        self.clone_repo()

    def check_repo(self) -> None:
        """Check input file for Git repository."""
        # Check input file
        if not self.opt['input'].exists():
            return

        self.brewinfo.file = self.opt['input']

        # Check input file if it points repository or not
        self.opt['repo'] = ''
        with Path(self.opt['input']).open() as f:
            lines = f.readlines()
        for line in lines:
            if re.match(' *git ', line) is None:
                continue
            git_line = line.split()
            if len(git_line) > 1:
                self.opt['repo'] = git_line[1]
                break
        if self.opt['repo'] == '':
            return

        # Check repository name and add git@github.com: if necessary
        if (
            '@' not in self.opt['repo']
            and not self.opt['repo'].startswith('git://')
            and not self.opt['repo'].startswith('http://')
            and not self.opt['repo'].startswith('file://')
            and not self.opt['repo'].startswith('/')
        ):
            self.opt['repo'] = (
                'git@github.com:' + self.user_name() + '/' + self.repo_name()
            )

        # Set Brewfile in the repository
        self.brewinfo.file = self.repo_file()

        # If repository does not have a branch, make it
        if self.brewinfo.check_dir():
            self.init_repo()
            return

        # Check and prepare repository
        if 'github' in self.opt['repo']:
            self.check_github_repo()
        elif self.opt['repo'].startswith('file://') or self.opt[
            'repo'
        ].startswith('/'):
            self.check_local_repo()
        else:
            self.clone_repo()

    def check_gitconfig(self) -> bool:
        if self.opt['repo'].startswith('git://') or self.opt[
            'repo'
        ].startswith('http'):
            self.log.info(
                f'You are using repository of {self.opt["repo"]}\n'
                'Use ssh protocol to push your Brewfile update.',
            )
            return False
        _, name = self.helper.proc(
            'git config user.name',
            print_cmd=False,
            print_out=False,
            exit_on_err=False,
            separate_err=True,
        )
        _, email = self.helper.proc(
            'git config user.email',
            print_cmd=False,
            print_out=False,
            exit_on_err=False,
            separate_err=True,
        )
        if not name or not email:
            self.log.warning(
                "You don't have user/email information in your .gitconfig.\n"
                'To commit and push your update, run\n'
                '  git config --global user.email "you@example.com"\n'
                '  git config --global user.name "Your Name"\n'
                'and try again.',
            )
            return False
        return True

    def repomgr(self, cmd: str = 'pull') -> None:
        """Manage repository."""
        # Check the repository
        if self.opt['repo'] == '':
            msg = (
                f'Please set a repository, or reset with:\n'
                f'$ {__prog__} set_repo\n'
            )
            raise RuntimeError(msg)

        # Clone if it doesn't exist
        if not self.brewinfo.check_dir():
            self.clone_repo()

        # pull/push
        dirname = self.brewinfo.get_dir()

        ret, lines = self.helper.proc(
            'git status -s -uno',
            print_cmd=False,
            print_out=False,
            exit_on_err=True,
            cwd=dirname,
        )
        if ret != 0:
            msg = '\n'.join(lines)
            raise RuntimeError(msg)
        if lines and self.check_gitconfig():
            _ = self.helper.proc(
                'git add -A',
                dryrun=self.opt['dryrun'],
                cwd=dirname,
            )
            _ = self.helper.proc(
                ['git', 'commit', '-m', '"Update the package list"'],
                exit_on_err=False,
                dryrun=self.opt['dryrun'],
                cwd=dirname,
            )

        _ = self.helper.proc(
            f'git {cmd}',
            dryrun=self.opt['dryrun'],
            cwd=dirname,
        )

    def brew_cmd(self) -> None:
        noinit = False
        if self.opt['args'] and 'noinit' in self.opt['args']:
            noinit = True
            self.opt['args'].remove('noinit')

        exe = ['brew']
        cmd = self.opt['args'][0] if self.opt['args'] else ''
        subcmd = self.opt['args'][1] if len(self.opt['args']) > 1 else ''
        args = self.opt['args']
        if cmd == 'mas':
            exe = ['mas']
            self.opt['args'].pop(0)
            if subcmd == 'uninstall':
                exe = ['sudo', 'mas']
            package = self.opt['args'][1:] if len(self.opt['args']) > 1 else ''
            if self.check_mas_cmd(True) != 1:
                msg = "\n'mas' command is not available.\n"
                if package:
                    msg += f"Please install 'mas' or manage {shlex.join(package)} manually"
                raise RuntimeError(msg)
        if cmd == 'whalebrew':
            exe = ['whalebrew']
            self.opt['args'].pop(0)
            if subcmd == 'uninstall':
                self.opt['args'].append('-y')
            if self.check_whalebrew_cmd(True) != 1:
                msg = "\n'whalebrew' command is not available.\n"
                raise RuntimeError(msg)
        if cmd == 'code':
            exe = ['code']
            self.opt['args'].pop(0)
            if self.check_vscode_cmd(True) != 1:
                msg = "\n'code' command (for VSCode) is not available.\n"
                raise RuntimeError(msg)
        if cmd == 'cursor':
            exe = ['cursor']
            self.opt['args'].pop(0)
            if self.check_cursor_cmd(True) != 1:
                msg = "\n'cursor' command is not available.\n"
                raise RuntimeError(msg)
        if cmd == 'codium':
            exe = ['codium']
            self.opt['args'].pop(0)
            if self.check_codium_cmd(True) != 1:
                msg = "\n'codium' command (for VSCodium) is not available.\n"
                raise RuntimeError(msg)

        ret, lines = self.helper.proc(
            exe + self.opt['args'],
            print_cmd=False,
            print_out=True,
            exit_on_err=False,
            dryrun=self.opt['dryrun'],
        )
        if self.opt['dryrun']:
            return

        if (
            noinit
            or (cmd == 'mas' and self.opt['appstore'] != 1)
            or (cmd == 'whalebrew' and self.opt['whalebrew'] != 1)
            or (cmd == 'code' and self.opt['vscode'] != 1)
            or (cmd == 'cursor' and self.opt['cursor'] != 1)
            or (cmd == 'codium' and self.opt['codium'] != 1)
            or (
                ret != 0
                and 'Not installed' not in ' '.join(lines)
                and 'No installed keg or cask with the name'
                not in ' '.join(lines)
            )
        ):
            return

        if cmd in ['cask']:
            args = self.opt['args'][2:]
        else:
            args = self.opt['args'][1:]
        nargs = len(args)

        if (
            cmd
            not in [
                'instal',
                'install',
                'reinstall',
                'tap',
                'rm',
                'remove',
                'uninstall',
                'untap',
                'cask',
                'mas',
                'whalebrew',
                'code',
                'cursor',
                'codium',
            ]
            or nargs == 0
            or (
                cmd == 'cask'
                and subcmd
                not in ['instal', 'install', 'rm', 'remove', 'uninstall']
            )
            or (
                cmd == 'mas'
                and subcmd not in ['purchase', 'install', 'uninstall']
            )
            or (cmd == 'whalebrew' and subcmd not in ['install', 'uninstall'])
            or (
                cmd == 'code'
                and subcmd
                not in ['--install-extension', '--uninstall-extension']
            )
            or (
                cmd == 'cursor'
                and subcmd
                not in ['--install-extension', '--uninstall-extension']
            )
            or (
                cmd == 'codium'
                and subcmd
                not in ['--install-extension', '--uninstall-extension']
            )
        ):
            # Not install/remove command, no init.
            return

        _ = self.initialize(check=False, debug_out=True)

    def add_path(self) -> None:
        env_path = os.getenv('PATH', '')
        paths = env_path.split(':')
        for path in [
            '/home/linuxbrew/.linuxbrew/bin',
            os.getenv('HOME', '') + '/.linuxbrew/bin',
            '/opt/homebrew/bin',
            '/usr/local/bin',
        ]:
            if path not in paths:
                os.environ['PATH'] = path + ':' + env_path

    def which_brew(self) -> bool:
        ret, cmd = self.helper.proc(
            'which brew',
            print_cmd=False,
            print_out=False,
            exit_on_err=False,
        )
        if ret == 0:
            self.opt['brew_cmd'] = cmd[0]
            self.opt['is_brew_cmd'] = True
            return True
        return False

    def check_brew_cmd(self) -> bool:
        """Check Homebrew."""
        if self.opt.get('is_brew_cmd', False):
            return True

        if self.which_brew():
            return True

        self.add_path()
        if self.which_brew():
            return True

        self.log.info('Homebrew has not been installed, install now...')
        with tempfile.NamedTemporaryFile() as f:
            cmd = (
                f'curl -o {f.name} -O https://raw.githubusercontent.com/'
                'Homebrew/install/master/install.sh'
            )
            _ = self.helper.proc(
                cmd,
                print_cmd=True,
                print_out=True,
                exit_on_err=False,
            )
            cmd = f'bash {f.name}'
            _ = self.helper.proc(
                cmd,
                print_cmd=True,
                print_out=True,
                exit_on_err=False,
            )
        if not self.which_brew():
            return False
        ret, lines = self.helper.proc(
            'brew doctor',
            print_cmd=True,
            print_out=True,
            exit_on_err=False,
        )
        if ret != 0:
            for line in lines:
                self.log.info(line)
            self.log.warning(
                '\n\nCheck brew environment and fix problems if necessary.\n'
                '# You can check by:\n'
                '#     $ brew doctor',
            )
        return True

    def check_cmd(
        self,
        flag: str,
        cmd: str,
        formula: str,
        install: bool = False,
    ) -> Literal[-2, -1, 0, 1]:
        """Check command is installed or not."""
        if self.opt[flag] != 0:
            return self.opt[flag]

        if shutil.which(cmd) is None:
            if not install:
                return self.opt[flag]
            self.log.info(f'{formula} has not been installed.')
            ret, _ = self.helper.proc(
                ['brew', 'install', formula],
                print_cmd=True,
                print_out=True,
                exit_on_err=False,
            )
            if ret != 0:
                self.log.error(f'\nFailed to install {formula}\n')
                self.opt[flag] = -1
                return self.opt[flag]
            p = Path(formula).name
            if p not in self.get_list('brew_list'):
                self.brewinfo.brew_list.append(p)
                self.brewinfo.brew_opt_list[p] = ''

        if shutil.which(cmd) is None:
            msg = f'Failed to prepare {cmd} command.'
            raise RuntimeError(msg)

        self.opt[flag] = 1
        return self.opt[flag]

    def check_mas_cmd(self, install: bool = False) -> Literal[-2, -1, 0, 1]:
        """Check mas is installed or not."""
        if self.opt['is_mas_cmd'] != 0:
            return self.opt['is_mas_cmd']

        if not is_mac():
            msg = 'mas is not available on Linux!'
            raise RuntimeError(msg)

        _, lines = self.helper.proc(
            'sw_vers -productVersion',
            print_cmd=False,
            print_out=False,
            exit_on_err=False,
        )
        sw_vers = lines[0].split('.')
        if int(sw_vers[0]) < 10 or (
            int(sw_vers[0]) == 10 and int(sw_vers[1]) < 11
        ):
            self.log.warning('You are using older OS X. mas can not be used.')
            self.opt['is_mas_cmd'] = -1
            return self.opt['is_mas_cmd']

        cmd_ret = self.check_cmd(
            'is_mas_cmd',
            self.opt['mas_cmd'],
            self.opt['mas_formula'],
            install,
        )
        if cmd_ret != 1:
            return cmd_ret

        # # Disable check until this issue is solved:
        # # https://github.com/mas-cli/mas#%EF%B8%8F-known-issues
        # if self.helper.proc(self.opt["mas_cmd"] + " account", print_cmd=False,
        #             print_out=False, exit_on_err=False)[0] != 0:
        #    msg = "Please sign in to the App Store."
        #    raise RuntimeError(msg)

        is_tmux = os.getenv('TMUX', '')
        if is_tmux != '':
            ret, _ = self.helper.proc(
                'type reattach-to-user-namespace',
                print_cmd=False,
                print_out=False,
                exit_on_err=False,
            )
            if ret != 0:
                f'You need {self.opt["reattach_formula"]} in tmux. Installing it.'
                ret, _ = self.helper.proc(
                    ['brew', 'install', self.opt['reattach_formula']],
                    print_cmd=True,
                    print_out=True,
                    exit_on_err=False,
                )
                if ret != 0:
                    self.log.error(
                        f'\nFailed to install {self.opt["reattach_formula"]}\n',
                    )
                    self.opt['is_mas_cmd'] = -1
                    return self.opt['is_mas_cmd']
                p = Path(self.opt['reattach_formula']).name
                if p not in self.get_list('brew_list'):
                    self.brewinfo.brew_list.append(p)
                    self.brewinfo.brew_opt_list[p] = ''
                self.opt['reattach_cmd_installed'] = True
            self.opt['mas_cmd'] = 'reattach-to-user-namespace mas'

        return self.opt['is_mas_cmd']

    def check_whalebrew_cmd(
        self,
        install: bool = False,
    ) -> Literal[-2, -1, 0, 1]:
        """Check whalebrew is installed or not."""
        if self.opt['is_whalebrew_cmd'] != 0:
            return self.opt['is_whalebrew_cmd']

        return self.check_cmd(
            'is_whalebrew_cmd',
            self.opt['whalebrew_cmd'],
            self.opt['whalebrew_formula'],
            install,
        )

    def check_vscode_cmd(self, install: bool = False) -> Literal[-2, -1, 0, 1]:
        """Check code (for VSCode) is installed or not."""
        if self.opt['is_vscode_cmd'] != 0:
            return self.opt['is_vscode_cmd']

        return self.check_cmd(
            'is_vscode_cmd',
            self.opt['vscode_cmd'],
            self.opt['vscode_formula'],
            install,
        )

    def check_cursor_cmd(self, install: bool = False) -> Literal[-2, -1, 0, 1]:
        """Check cursor is installed or not."""
        if self.opt['is_cursor_cmd'] != 0:
            return self.opt['is_cursor_cmd']

        return self.check_cmd(
            'is_cursor_cmd',
            self.opt['cursor_cmd'],
            self.opt['cursor_formula'],
            install,
        )

    def check_codium_cmd(self, install: bool = False) -> Literal[-2, -1, 0, 1]:
        """Check codium is installed or not."""
        if self.opt['is_codium_cmd'] != 0:
            return self.opt['is_codium_cmd']

        return self.check_cmd(
            'is_codium_cmd',
            self.opt['codium_cmd'],
            self.opt['codium_formula'],
            install,
        )

    def check_docker_running(self) -> Literal[-2, -1, 0, 1]:
        """Check if Docker is running."""
        if self.opt['docker_running'] != 0:
            return self.opt['docker_running']
        ret, _ = self.helper.proc(
            'type docker',
            print_cmd=False,
            print_out=False,
            exit_on_err=False,
        )
        if ret != 0:
            self.opt['docker_running'] = -1
            return self.opt['docker_running']
        ret, _ = self.helper.proc(
            'docker ps',
            print_cmd=False,
            print_out=False,
            exit_on_err=False,
        )
        if ret != 0:
            self.opt['docker_running'] = -2
            return self.opt['docker_running']
        self.opt['docker_running'] = 1
        return self.opt['docker_running']

    def get_appstore_dict(self) -> dict[str, list[str]]:
        apps: dict[str, list[str]] = {}
        _, apps_tmp = self.helper.proc(
            "mdfind 'kMDItemAppStoreHasReceipt=1'",
            print_cmd=False,
            print_out=False,
        )
        for a in apps_tmp:
            if not a.endswith('.app'):
                self.log.warning(f'Incorrect app name in mdfind: {a}')
                continue
            if not Path(a).is_dir():
                self.log.warning(f"App doesn't exist: {a}")
                continue
            _, lines = self.helper.proc(
                f'mdls -attr kMDItemAppStoreAdamID -attr kMDItemVersion {shlex.quote(a)}',
                print_cmd=False,
                print_out=False,
            )
            app = {
                x.split('=')[0].strip(): x.split('=')[1].strip() for x in lines
            }
            app_id = app['kMDItemAppStoreAdamID']
            if app_id != '(null)':
                app_name = a.split('/')[-1].split('.app')[0]
                app_version = app['kMDItemVersion'].strip('"')
                apps[app_name] = [app_id, f'({app_version})']
        return apps

    def get_appstore_list(self) -> list[str]:
        return [
            f'{v[0]} {k} {v[1]}' for k, v in self.get_appstore_dict().items()
        ]

    def get_whalebrew_list(self) -> list[str]:
        if self.opt['whalebrew'] != 1:
            return []
        if self.check_whalebrew_cmd(False) != 1:
            return []
        _, lines = self.helper.proc(
            f'{self.opt["whalebrew_cmd"]} list',
            print_cmd=False,
            print_out=False,
            exit_on_err=False,
        )
        return [x.split()[1] for x in lines if x.split()[0] != 'COMMAND']

    def get_vscode_list(self) -> list[str]:
        if self.opt['vscode'] != 1:
            return []
        if self.check_vscode_cmd(False) != 1:
            return []
        # Remove stderr output for SecCodeCheckValidity issue:
        # https://github.com/microsoft/vscode/issues/204085
        # https://github.com/microsoft/vscode/issues/204447
        _, lines = self.helper.proc(
            f'{self.opt["vscode_cmd"]} --list-extensions',
            print_cmd=False,
            print_out=False,
            exit_on_err=False,
            separate_err=True,
            print_err=False,
        )
        return lines

    def get_cursor_list(self) -> list[str]:
        if self.opt['cursor'] != 1:
            return []
        if self.check_cursor_cmd(False) != 1:
            return []
        _, lines = self.helper.proc(
            f'{self.opt["cursor_cmd"]} --list-extensions',
            print_cmd=False,
            print_out=False,
            exit_on_err=False,
            separate_err=True,
            print_err=False,
        )
        return lines

    def get_codium_list(self) -> list[str]:
        if self.opt['codium'] != 1:
            return []
        if self.check_codium_cmd(False) != 1:
            return []
        _, lines = self.helper.proc(
            f'{self.opt["codium_cmd"]} --list-extensions',
            print_cmd=False,
            print_out=False,
            exit_on_err=False,
            separate_err=True,
            print_err=False,
        )
        return lines

    def get_installed_formulae(self) -> list[str]:
        full_list = self.helper.get_formula_list()
        if not self.brewinfo.brew_full_list:
            self.brewinfo.brew_full_list.extend(full_list)
        if self.opt['leaves']:
            packages = self.helper.get_leaves(
                on_request=self.opt['on_request'],
            )
        elif self.opt['on_request']:
            packages = []
            for p in full_list:
                installed = self.helper.get_installed(p)
                if installed.get('installed_on_request', True) in [
                    True,
                    None,
                ]:
                    packages.append(p)
        else:
            packages = copy.deepcopy(full_list)

        for p in self.opt['top_packages'].split(','):
            if p == '':
                continue
            if p in full_list and p not in packages:
                packages.append(p)
        return packages

    def get_installed_packages(
        self,
        force_appstore_list: bool = False,
    ) -> None:
        """Get Installed Package List."""
        # Clear lists
        for bi in [*self.brewinfo_ext, self.brewinfo_main]:
            bi.clear_list()

        # Brew packages
        if not self.opt['caskonly']:
            for p in self.get_installed_formulae():
                self.brewinfo.brew_list.append(p)
                self.brewinfo.brew_opt_list[p] = self.helper.get_option(p)

        # Taps
        _, lines = self.helper.proc(
            'brew tap',
            print_cmd=False,
            print_out=False,
        )

        self.brewinfo.set_list_val('tap_list', lines)
        if self.opt['api'] and self.opt[
            'core_repo'
        ] not in self.brewinfo.get_list('tap_list'):
            self.brewinfo.add_to_list('tap_list', [self.opt['core_repo']])
        if (
            is_mac()
            and self.opt['api']
            and self.opt['cask_repo'] not in self.brewinfo.get_list('tap_list')
        ):
            self.brewinfo.add_to_list('tap_list', [self.opt['cask_repo']])

        # Casks
        if is_mac():
            for p in self.helper.get_cask_list():
                if len(p.split()) == 1:
                    self.brewinfo.cask_list.append(p)
                else:
                    self.log.warning(
                        f"The cask file of {p} doesn't exist.",
                    )
                    self.log.warning('Please check later.\n\n')
                    self.brewinfo.cask_nocask_list.append(p)

        # App Store
        if is_mac():
            if self.opt['appstore'] == 1 or (
                self.opt['appstore'] == 2 and force_appstore_list
            ):
                self.brewinfo.set_list_val(
                    'appstore_list',
                    self.get_appstore_list(),
                )
            elif self.opt['appstore'] == 2:
                if self.brewinfo.check_file():
                    self.read_all()
                self.brewinfo.set_list_val(
                    'appstore_list',
                    list(self.get_list('appstore_input')),
                )

        # Whalebrew commands
        if self.opt['whalebrew']:
            self.brewinfo.set_list_val(
                'whalebrew_list',
                self.get_whalebrew_list(),
            )

        # VSCode extensions
        if self.opt['vscode']:
            self.brewinfo.set_list_val('vscode_list', self.get_vscode_list())

        # Cursor extensions
        if self.opt['cursor']:
            self.brewinfo.set_list_val('cursor_list', self.get_cursor_list())
        # Codium extensions
        if self.opt['codium']:
            self.brewinfo.set_list_val('codium_list', self.get_codium_list())

    def clean_list(self) -> None:
        """Remove duplications between brewinfo.list to extra files' input."""
        # Cleanup extra files
        formula_aliases = self.helper.get_formula_aliases(flat=True)
        cask_aliases = self.helper.get_cask_aliases(flat=True)

        # Remove aliases and not installed packages
        for b in [*self.brewinfo_ext, self.brewinfo_main]:
            for line in [
                'brew',
                'tap',
                'cask',
                'appstore',
                'whalebrew',
                'vscode',
                'cursor',
                'codium',
            ]:
                for p in b.get_list(line + '_input'):
                    # Keep aliases
                    if (
                        line == 'brew'
                        and p in formula_aliases
                        and formula_aliases[p]
                        in self.brewinfo.get_list('brew_list')
                    ):
                        self.brewinfo.add_to_list('brew_list', [p])
                        self.brewinfo.add_to_dict(
                            'brew_opt_list',
                            {
                                p: self.brewinfo.get_dict('brew_opt_list')[
                                    formula_aliases[p]
                                ],
                            },
                        )
                        self.brewinfo.remove(
                            'brew_list',
                            formula_aliases[p],
                        )
                        self.brewinfo.remove(
                            'brew_opt_list',
                            formula_aliases[p],
                        )
                    if (
                        line == 'cask'
                        and p in cask_aliases
                        and cask_aliases[p]
                        in self.brewinfo.get_list('cask_list')
                    ):
                        self.brewinfo.add_to_list('cask_list', [p])
                        self.brewinfo.remove('cask_list', cask_aliases[p])

                    if p not in self.brewinfo.get_list(line + '_list'):
                        b.remove(line + '_input', p)

        # Copy list to main file
        self.list_to_main()

        # Loop over lists to remove duplications.
        # tap_list is not checked for overlap removal.
        # Keep it in main list in any case.
        for name in [
            'brew',
            'cask',
            'cask_nocask',
            'appstore',
            'whalebrew',
            'vscode',
            'cursor',
            'codium',
        ]:
            i = 'cask' if name == 'cask_nocask' else name
            for p in self.brewinfo_main.get_list(name + '_list'):
                if p in self.get_list(i + '_input', True):
                    self.brewinfo_main.remove(name + '_list', p)

        # Keep mian/file in main Brewfile
        self.brewinfo_main.add_to_list(
            'main_list',
            self.brewinfo_main.main_input,
        )
        self.brewinfo_main.add_to_list(
            'file_list',
            self.brewinfo_main.file_input,
        )

        # Copy input to list for extra files.
        self.input_to_list(only_ext=True)

    def input_backup(self) -> bool:
        if self.opt['backup'] != '':
            Path(self.opt['input']).rename(Path(self.opt['backup']))
            self.log.info(f'Old input file was moved to {self.opt["backup"]}')
        else:
            ans = self.ask_yn('Do you want to overwrite it?')
            if not ans:
                return False
        return True

    def set_brewfile_local(self) -> None:
        """Set Brewfile to local file."""
        self.opt['repo'] = ''
        _ = self.initialize(check=False, check_input=False)

    def set_brewfile_repo(self) -> bool:
        """Set Brewfile repository."""
        # Check input file
        if self.opt['input'].exists():
            prev_repo = ''
            with Path(self.opt['input']).open() as f:
                lines = f.readlines()
            for line in lines:
                if re.match(' *git ', line) is None:
                    continue
                git_line = line.split()
                if len(git_line) > 1:
                    prev_repo = git_line[1]
                    break
            if self.opt['repo'] == '':
                self.log.info(
                    f'Input file: {self.opt["input"]} is already there.',
                )
                if prev_repo != '':
                    self.log.info(
                        f'git repository for Brewfile is already set as {prev_repo}.',
                    )

            if not self.input_backup():
                return False

        # Get repository
        if self.opt['repo'] == '':
            self.log.info(
                '\nSet repository,\n'
                '"non" (or empty) for local Brewfile '
                f'({self.opt["input"]}),\n'
                '/path/to/repo for local git repository,\n'
                'https://your/git/repository '
                '(or ssh://user@server.project.git) for git repository,\n'
                'or (<user>/)<repo> for github repository,',
            )
            self.opt['repo'] = input('or full path for other git repository: ')
            self.banner('# Set Brewfile repository as ' + self.opt['repo'])

        if self.opt['repo'] in ['non', '']:
            self.set_brewfile_local()
        else:
            # Write repository to the input file
            with OpenWrapper(self.opt['input'], 'w') as f:
                f.write('git ' + self.opt['repo'])
            self.check_repo()
        return True

    def initialize(
        self,
        check: bool = True,
        check_input: bool = True,
        debug_out: bool = False,
    ) -> bool:
        """Initialize Brewfile."""
        if self.opt['initialized']:
            return True

        if check:
            if not self.opt['input'].exists():
                if not self.opt['no_repo']:
                    ans = self.ask_yn(
                        'Do you want to set a repository (y)? '
                        '((n) for local Brewfile).',
                    )
                    if ans and not self.set_brewfile_repo():
                        return False
            elif self.opt['repo'] != '':
                self.log.info(
                    f'You are using Brewfile of {self.opt["repo"]}.',
                )
            else:
                self.log.info(f'{self.opt["input"]} is already there.')
                if not self.input_backup():
                    return False

        # Get installed package list
        self.get_installed_packages()

        # Read inputs
        if check_input:
            if self.brewinfo.check_file():
                self.read_all()

            # Remove duplications between brewinfo.list to extra files' input
            self.clean_list()

        # write out
        self.initialize_write(debug_out=debug_out)

        return True

    def initialize_write(self, debug_out: bool = False) -> None:
        self.write(debug_out=debug_out)
        self.banner(
            f'# You can edit {self.brewinfo.file} with:\n'
            f'#     $ {__prog__} edit',
            debug_out=debug_out,
        )
        self.opt['initialized'] = True

    def check_input_file(self) -> None:
        """Check input file."""
        if not self.brewinfo.check_file():
            self.log.warning(f'Input file {self.brewinfo.file} is not found.')
            ans = self.ask_yn(
                'Do you want to initialize from installed packages?',
            )
            if ans:
                _ = self.initialize(check=False)

            msg = (
                f'Ok, please prepare brewfile\n'
                f'or you can initialize {self.brewinfo.file} with:    $ {__prog__} init'
            )
            raise RuntimeError(msg)

    def get_files(
        self,
        is_print: bool = False,
        all_files: bool = False,
        error_no_file: bool = True,
    ) -> list[Path]:
        """Get Brewfiles."""
        self.read_all()
        files = [
            x.file
            for x in [self.brewinfo_main, *self.brewinfo_ext]
            if all_files or x.file.exists()
        ]
        if error_no_file and not files:
            msg = 'No Brewfile found. Please run `brew file init` first.'
            raise RuntimeError(msg)
        if is_print:
            self.log.info('\n'.join([str(x) for x in files]))
        return files

    def edit_brewfile(self) -> None:
        """Edit brewfiles."""
        editor = shlex.split(self.opt['my_editor'])
        subprocess.call(editor + [str(x) for x in self.get_files()])

    def cat_brewfile(self) -> None:
        """Cat brewfiles."""
        subprocess.call(['cat'] + [str(x) for x in self.get_files()])

    def clean_non_request(self) -> None:
        """Clean up non requested packages."""
        cmd = 'brew autoremove'
        _ = self.helper.proc(
            cmd,
            print_cmd=False,
            print_out=True,
            dryrun=self.opt['dryrun'],
        )

    def cleanup(self, delete_cache: bool = True) -> None:
        """Clean up."""
        # Get installed package list
        self.get_installed_packages()

        # Check up packages in the input file
        self.read_all()

        # Remain formulae in dependencies
        info = self.helper.get_info()['formulae']

        def add_dependncies(package: str) -> None:
            for pac in info[package]['dependencies']:
                p = pac.split('/')[-1]
                if p not in info:
                    continue
                if p not in self.get_list('brew_input'):
                    self.brewinfo.brew_input.append(p)
                    self.brewinfo.brew_opt_input[p] = ''
                    add_dependncies(p)

        for p in self.get_list('brew_input'):
            if p not in info:
                continue
            add_dependncies(p)

        # Clean up Whalebrew images
        if self.opt['whalebrew'] == 1 and self.get_list('whalebrew_list'):
            self.banner('# Clean up Whalebrew images')

            for image in self.get_list('whalebrew_list'):
                if image in self.get_list('whalebrew_input'):
                    continue

                if self.check_whalebrew_cmd(True) == 1:
                    cmd = f'{self.opt["whalebrew_cmd"]} uninstall -y {image.split("/")[-1]}'
                    _ = self.helper.proc(
                        cmd,
                        print_cmd=True,
                        print_out=True,
                        exit_on_err=False,
                        dryrun=self.opt['dryrun'],
                    )
                    self.remove_pack('whalebrew_list', image)

        # Clean up VSCode extensions
        if self.opt['vscode'] == 1 and self.get_list('vscode_list'):
            self.banner('# Clean up VSCode extensions')

            for e in self.get_list('vscode_list'):
                if e in self.get_list('vscode_input'):
                    continue

                if self.check_vscode_cmd(True) == 1:
                    cmd = f'{self.opt["vscode_cmd"]} --uninstall-extension {e}'
                    _ = self.helper.proc(
                        cmd,
                        print_cmd=True,
                        print_out=True,
                        exit_on_err=False,
                        separate_err=True,
                        print_err=False,
                        dryrun=self.opt['dryrun'],
                    )
                    self.remove_pack('vscode_list', e)

        # Clean up Cursor extensions
        if self.opt['cursor'] == 1 and self.get_list('cursor_list'):
            self.banner('# Clean up Cursor extensions')

            for e in self.get_list('cursor_list'):
                if e in self.get_list('cursor_input'):
                    continue

                if self.check_cursor_cmd(True) == 1:
                    cmd = f'{self.opt["cursor_cmd"]} --uninstall-extension {e}'
                    _ = self.helper.proc(
                        cmd,
                        print_cmd=True,
                        print_out=True,
                        exit_on_err=False,
                        separate_err=True,
                        print_err=False,
                        dryrun=self.opt['dryrun'],
                    )
                    self.remove_pack('cursor_list', e)

        # Clean up Codium extensions
        if self.opt['codium'] == 1 and self.get_list('codium_list'):
            self.banner('# Clean up Codium extensions')

            for e in self.get_list('codium_list'):
                if e in self.get_list('codium_input'):
                    continue

                if self.check_codium_cmd(True) == 1:
                    cmd = f'{self.opt["codium_cmd"]} --uninstall-extension {e}'
                    _ = self.helper.proc(
                        cmd,
                        print_cmd=True,
                        print_out=True,
                        exit_on_err=False,
                        separate_err=True,
                        print_err=False,
                        dryrun=self.opt['dryrun'],
                    )
                    self.remove_pack('codium_list', e)

        # Clean up App Store applications
        if self.opt['appstore'] == 1 and self.get_list('appstore_list'):
            self.banner('# Clean up App Store applications')

            for p in self.get_list('appstore_list'):
                identifier = p.split()[0]
                if identifier.isdigit():
                    package = ' '.join(p.split()[1:])
                else:
                    identifier = ''
                    package = p
                if re.match(r'.*\(\d+\.\d+.*\)$', package):
                    package = ' '.join(package.split(' ')[:-1])

                isinput = False
                for pi in self.get_list('appstore_input'):
                    i_identifier = pi.split()[0]
                    if i_identifier.isdigit():
                        i_package = ' '.join(pi.split()[1:])
                    else:
                        i_identifier = ''
                        i_package = pi
                    if re.match(r'.*\(\d+\.\d+.*\)$', i_package):
                        i_package = ' '.join(i_package.split(' ')[:-1])
                    if (
                        identifier != '' and identifier == i_identifier
                    ) or package == i_package:
                        isinput = True
                        break
                if isinput:
                    continue

                if identifier and self.check_mas_cmd(True) == 1:
                    cmd = (
                        'sudo '
                        + self.opt['mas_cmd']
                        + ' uninstall '
                        + identifier
                    )
                else:
                    ret, _ = self.helper.proc(
                        'type uninstall',
                        print_cmd=False,
                        print_out=False,
                        exit_on_err=False,
                    )
                    cmd = 'sudo uninstall' if ret == 0 else 'sudo rm -rf'
                    tmpcmd = cmd
                    for d in self.opt['appdirlist']:
                        a = f'{d}/{package}.app'
                        if Path(a).is_dir():
                            if ret == 0:
                                cmd += ' file://' + quote(a)
                            else:
                                cmd += f" '{a}'"
                            continue
                    if cmd == tmpcmd:
                        self.log.warning(
                            f'Package {package} was not found:'
                            'nothing to do.\n',
                        )
                        self.remove_pack('appstore_list', p)
                        continue
                _ = self.helper.proc(
                    cmd,
                    print_cmd=True,
                    print_out=True,
                    exit_on_err=False,
                    dryrun=self.opt['dryrun'],
                )
                self.remove_pack('appstore_list', p)

        # Clean up cask packages
        if is_mac() and self.get_list('cask_list'):
            self.banner('# Clean up cask packages')
            non_alias_cask_input = self.get_non_alias_input('casks')
            uninstalls = []
            for p in self.get_list('cask_list'):
                if p in non_alias_cask_input:
                    continue
                uninstalls.append(p)
                self.remove_pack('cask_list', p)

            if uninstalls:
                cmd = 'brew uninstall ' + shlex.join(uninstalls)
                _ = self.helper.proc(
                    cmd,
                    print_cmd=True,
                    print_out=True,
                    dryrun=self.opt['dryrun'],
                )

        # Clean up brew packages
        if self.get_list('brew_list'):
            self.banner('# Clean up brew packages')
            non_alias_brew_input = self.get_non_alias_input('formulae')
            uninstalls = []
            for p in self.get_list('brew_list'):
                if p in non_alias_brew_input:
                    continue
                uninstalls.append(p)
                # Use --ignore-dependencies option to remove packages w/o
                # formula (tap of which could be removed before).
            if uninstalls:
                cmd = 'brew uninstall --ignore-dependencies ' + shlex.join(
                    uninstalls
                )
                _ = self.helper.proc(
                    cmd,
                    print_cmd=False,
                    print_out=True,
                    dryrun=self.opt['dryrun'],
                )

        # Clean up tap packages
        if self.get_list('tap_list'):
            self.banner('# Clean up tap packages')
            untaps = []
            for p in self.get_list('tap_list'):
                # Skip core and cask taps
                if p in [self.opt['core_repo'], self.opt['cask_repo']]:
                    continue
                if p in self.get_list('tap_input'):
                    continue
                tap_packs = self.helper.get_tap_packs(p, alias=True)
                untapflag = True
                for tp in tap_packs['formulae']:
                    if tp in self.get_list('brew_input'):
                        # Keep the Tap as related package is remained
                        untapflag = False
                        break
                if not untapflag:
                    continue
                if is_mac():
                    for tc in tap_packs['casks']:
                        if tc in self.get_list('cask_input'):
                            # Keep the Tap as related cask is remained
                            untapflag = False
                            break
                if not untapflag:
                    continue
                untaps.append(p)

            if untaps:
                cmd = 'brew untap ' + shlex.join(untaps)
                _ = self.helper.proc(
                    cmd,
                    print_cmd=True,
                    print_out=True,
                    dryrun=self.opt['dryrun'],
                )

        # Clean up cashe
        self.banner('# Clean up cache')
        cmd0 = 'brew cleanup'
        _ = self.helper.proc(
            cmd0,
            print_cmd=True,
            print_out=True,
            dryrun=self.opt['dryrun'],
        )
        if delete_cache:
            cmd1 = 'rm -rf ' + self.helper.brew_val('cache')
            _ = self.helper.proc(
                cmd1,
                print_cmd=True,
                print_out=True,
                dryrun=self.opt['dryrun'],
            )

    def install(self) -> None:
        # Get installed package list
        self.get_installed_packages(force_appstore_list=True)

        # Check packages in the input file
        self.read_all()

        # before commands
        for c in self.get_list('before_input'):
            _ = self.helper.proc(c, dryrun=self.opt['dryrun'])

        # Tap
        for p in self.get_list('tap_input'):
            if p in self.get_list('tap_list'):
                continue
            _ = self.helper.proc('brew tap ' + p, dryrun=self.opt['dryrun'])

        # Cask
        if is_mac():
            cask_args_opt = {'--cask': '', '--force': ''}
            cask_args_opt.update(self.get_dict('cask_args_input'))

            cask_aliases = self.helper.get_cask_aliases(flat=True)
            casks_to_install: list[str] = []

            for p in self.get_list('cask_input'):
                pack = cask_aliases.get(p, p)
                if pack in self.get_list('cask_list'):
                    continue
                casks_to_install.append(p)

            if casks_to_install:
                args: list[str] = []
                for k, v in cask_args_opt.items():
                    args.append(k)
                    if v != '':
                        args.append(v)
                cmd = 'brew install ' + shlex.join(args + casks_to_install)
                _ = self.helper.proc(cmd, dryrun=self.opt['dryrun'])

        # Brew
        if not self.opt['caskonly']:
            formula_aliases = self.helper.get_formula_aliases(flat=True)
            batched_packages: list[str] = []
            individual_installs: list[tuple[str, str]] = []

            def handle_install_output(lines: list[str]) -> None:
                for line in lines:
                    if line.find('ln -s') != -1 and self.opt['link']:
                        cmdtmp = line.split()
                        cmd_ln = [str(expandpath(c)) for c in cmdtmp]
                        _ = self.helper.proc(cmd_ln)
                    if line.find('brew linkapps') != -1 and self.opt['link']:
                        _ = self.helper.proc('brew linkapps')

            for p in self.get_list('brew_input'):
                pack = formula_aliases.get(p, p)
                opts = self.get_dict('brew_opt_input')[p]
                if pack in self.get_list('brew_full_list'):
                    if p not in self.get_dict('brew_opt_list') or sorted(
                        opts.split(),
                    ) == sorted(self.get_dict('brew_opt_list')[p].split()):
                        continue
                    # Uninstall to install the package with new options
                    # `reinstall` does not accept options such a --HEAD.
                    _ = self.helper.proc(
                        'brew uninstall ' + p,
                        dryrun=self.opt['dryrun'],
                    )
                if opts.strip():
                    individual_installs.append((p, opts))
                else:
                    batched_packages.append(p)

            if batched_packages:
                ret, lines = self.helper.proc(
                    'brew install ' + shlex.join(batched_packages),
                    dryrun=self.opt['dryrun'],
                )
                if ret != 0:
                    self.log.warning(
                        f'Failed to install packages: {", ".join(batched_packages)}. Please check the package names.'
                    )
                else:
                    handle_install_output(lines)

            for p, opts in individual_installs:
                ret, lines = self.helper.proc(
                    'brew install ' + p + opts,
                    dryrun=self.opt['dryrun'],
                )
                if ret != 0:
                    self.log.warning(
                        f'Can not install {p} .'
                        'Please check the package name.\n'
                        f'{p} may be installed '
                        'by using web direct formula.',
                    )
                    continue
                handle_install_output(lines)

        # App Store
        if is_mac() and self.opt['appstore']:
            id_list = [x.split()[0] for x in self.get_list('appstore_list')]
            for p in self.get_list('appstore_input'):
                identifier = p.split()[0]
                if identifier in id_list:
                    continue
                if identifier.isdigit() and len(identifier) >= 9:
                    package = ' '.join(p.split()[1:])
                else:
                    identifier = ''
                    package = p
                islist = False
                for pl in self.get_list('appstore_list'):
                    l_identifier = pl.split()[0]
                    if l_identifier.isdigit() and len(l_identifier) >= 9:
                        l_package = ' '.join(pl.split()[1:])
                    else:
                        l_identifier = ''
                        l_package = pl
                    if package == l_package:
                        islist = True
                        break
                if islist:
                    continue
                self.log.info(f'Installing {package}')
                if identifier != '':
                    if self.opt['dryrun'] or self.check_mas_cmd(True) == 1:
                        _ = self.helper.proc(
                            self.opt['mas_cmd'] + ' install ' + identifier,
                            dryrun=self.opt['dryrun'],
                        )
                    else:
                        self.log.info(
                            f'Please install {package} from AppStore.',
                        )
                        _ = self.helper.proc(
                            f"open -W 'macappstore://itunes.apple.com/app/id{identifier}'",
                            dryrun=self.opt['dryrun'],
                        )
                else:
                    self.log.warning(
                        'No id or wrong id information was given for '
                        f'AppStore App: {package}.\n'
                        'Please install it manually.',
                    )

        # Whalebrew commands
        if self.opt['whalebrew']:
            images = self.get_list('whalebrew_list')
            for image in self.get_list('whalebrew_input'):
                if image in images:
                    continue
                self.log.info(f'Installing {image}')
                if self.opt['dryrun'] or self.check_whalebrew_cmd(True) == 1:
                    if not self.opt[
                        'dryrun'
                    ] and self.check_docker_running() in [-1, -2]:
                        if self.check_docker_running() == -1:
                            self.log.warning(
                                'Docker command is not available.',
                            )
                        elif self.check_docker_running() == -2:
                            self.log.warning('Docker is not running.')
                        self.log.warning(
                            f'Please install {image} by whalebrew after docker is ready.',
                        )
                        continue
                    _ = self.helper.proc(
                        self.opt['whalebrew_cmd'] + ' install ' + image,
                        dryrun=self.opt['dryrun'],
                    )
                else:
                    self.log.warning(f'Please install {image} by whalebrew.')

        # VSCode extensions
        if self.opt['vscode']:
            extensions = self.get_list('vscode_list')
            for e in self.get_list('vscode_input'):
                if e in extensions:
                    continue
                self.log.info(f'Installing {e}')
                if self.opt['dryrun'] or self.check_vscode_cmd(True) == 1:
                    _ = self.helper.proc(
                        self.opt['vscode_cmd'] + ' --install-extension ' + e,
                        separate_err=True,
                        print_err=False,
                        dryrun=self.opt['dryrun'],
                    )
                else:
                    self.log.warning(f'Please install {e} to VSCode.')

        # Cursor extensions
        if self.opt['cursor']:
            extensions = self.get_list('cursor_list')
            for e in self.get_list('cursor_input'):
                if e in extensions:
                    continue
                self.log.info(f'Installing {e}')
                if self.opt['dryrun'] or self.check_cursor_cmd(True) == 1:
                    _ = self.helper.proc(
                        self.opt['cursor_cmd'] + ' --install-extension ' + e,
                        separate_err=True,
                        print_err=False,
                        dryrun=self.opt['dryrun'],
                    )
                else:
                    self.log.warning(f'Please install {e} to Cursor.')

        # Codium extensions
        if self.opt['codium']:
            extensions = self.get_list('codium_list')
            for e in self.get_list('codium_input'):
                if e in extensions:
                    continue
                self.log.info(f'Installing {e}')
                if self.opt['dryrun'] or self.check_codium_cmd(True) == 1:
                    _ = self.helper.proc(
                        self.opt['codium_cmd'] + ' --install-extension ' + e,
                        separate_err=True,
                        print_err=False,
                        dryrun=self.opt['dryrun'],
                    )
                else:
                    self.log.warning(f'Please install {e} to Codium.')

        # Other commands
        for c in self.get_list('cmd_input'):
            _ = self.helper.proc(c, dryrun=self.opt['dryrun'])

        # after commands
        for c in self.get_list('after_input'):
            _ = self.helper.proc(c, dryrun=self.opt['dryrun'])

    def generate_cask_token(self, app: str) -> str:
        # Ref: https://github.com/Homebrew/homebrew-cask/blob/c24db49e9489190949096156a1f97ee02c15c68b/developer/bin/generate_cask_token#L267
        token = app.split('/')[-1]
        token = token.removesuffix('.app')
        token = token.replace('+', 'plus')
        token = token.replace('@', 'at')
        token = token.replace(' ', '-').lower()
        token = re.sub(r'[^a-z0-9-]', '', token)
        token = re.sub(r'-+', '-', token)
        token = re.sub(r'^-+', '', token)
        return re.sub(r'-([0-9])', '\\g<1>', token)

    def make_brew_app_cmd(self, name: str, app_path: str) -> str:
        return f'brew {name} # {app_path}'

    def make_cask_app_cmd(self, name: str, app_path: str) -> str:
        return f'cask {name} # {app_path}'

    def make_appstore_app_cmd(self, name: str, app_path: str) -> str:
        return f'appstore {name} # {app_path}'

    def check_cask(self) -> None:
        """Check applications for Cask."""
        if not is_mac():
            msg = 'Cask is not available on Linux!'
            raise RuntimeError(msg)

        self.banner('# Starting to check applications for Cask...')

        # First, get App Store applications
        appstore_list = self.get_appstore_dict()

        # Get all available formulae/casks information
        all_info = self.helper.get_all_info()

        casks: dict[str, dict[str, str | bool]] = {}
        apps: dict[str, str] = {}
        installed_casks: dict[str, list[str]] = {self.opt['cask_repo']: []}
        for cask, info in all_info['casks'].items():
            installed = False
            latest = False
            if info.get('installed'):
                installed = True
                latest = info['installed'] == info['version']
                installed_casks[info['tap']] = [
                    *(
                        installed_casks.get(
                            info['tap'],
                            [],
                        )
                    ),
                    cask,
                ]

            apps_in_cask: list[str] = []
            if 'artifacts' in info:
                for artifact in info['artifacts']:
                    if 'app' in artifact:
                        apps_in_cask = apps_in_cask + [
                            a for a in artifact['app'] if isinstance(a, str)
                        ]
                    if 'uninstall' in artifact:
                        for uninstall in artifact['uninstall']:
                            if 'delete' in uninstall:
                                apps_in_cask = apps_in_cask + [
                                    a
                                    for a in uninstall['delete']
                                    if isinstance(a, str)
                                ]
            casks[cask] = {
                'tap': info['tap'],
                'installed': installed,
                'latest': latest,
            }
            apps_in_cask = list(set(apps_in_cask))
            for a in apps_in_cask:
                if a not in apps or installed:
                    apps[a] = cask

        # Set applications directories
        app_dirs = self.opt['appdirlist']
        apps_check = {
            'cask': dict.fromkeys(app_dirs, 0),
            'has_cask': dict.fromkeys(app_dirs, 0),
            'brew': dict.fromkeys(app_dirs, 0),
            'has_brew': dict.fromkeys(app_dirs, 0),
            'appstore': dict.fromkeys(app_dirs, 0),
            'no_cask': dict.fromkeys(app_dirs, 0),
        }

        appstore_apps: dict[str, str] = {}
        appstore_has_cask_apps: CaskInfo = {}
        cask_apps: CaskListInfo = {self.opt['cask_repo']: []}
        non_latest_cask_apps: CaskListInfo = {self.opt['cask_repo']: []}
        has_cask_apps: CaskListInfo = {self.opt['cask_repo']: []}
        brew_apps: CaskListInfo = {self.opt['core_repo']: []}
        has_brew_apps: CaskListInfo = {self.opt['core_repo']: []}
        no_cask: list[str] = []

        # Get applications
        napps = 0
        for d in app_dirs:
            for app in sorted(
                [
                    str(a)
                    for a in Path(d).iterdir()
                    if not str(a).startswith('.')
                    and str(a) != 'Utilities'
                    and (Path(d) / a).is_dir()
                ],
            ):
                check = 'no_cask'
                app_path = home_tilde(f'{d}/{app}')
                aname = app
                aname = aname.removesuffix('.app')
                if app in apps:
                    token = apps[app]
                elif app_path in apps:
                    token = apps[app_path]
                else:
                    token = self.generate_cask_token(app)

                if aname in appstore_list:
                    check = 'appstore'
                    name = (
                        appstore_list[aname][0]
                        + ' '
                        + aname
                        + ' '
                        + appstore_list[aname][1]
                    )
                    if token in casks:
                        appstore_has_cask_apps[name] = (token, app_path)
                    else:
                        appstore_apps[name] = app_path
                elif token in casks:
                    cask_tap = cast('str', casks[token]['tap'])
                    if casks[token]['installed']:
                        check = 'cask'
                        if casks[token]['latest']:
                            cask_apps[cask_tap] = [
                                *(
                                    cask_apps.get(
                                        cask_tap,
                                        [],
                                    )
                                ),
                                (app_path, token),
                            ]
                        else:
                            non_latest_cask_apps[cask_tap] = [
                                *(non_latest_cask_apps.get(cask_tap, [])),
                                (app_path, token),
                            ]
                        if token in installed_casks[cask_tap]:
                            installed_casks[cask_tap].remove(token)
                    else:
                        check = 'has_cask'
                        has_cask_apps[cask_tap] = [
                            *(
                                has_cask_apps.get(
                                    cask_tap,
                                    [],
                                )
                            ),
                            (app_path, token),
                        ]
                elif token in all_info['formulae']:
                    brew_tap = cast(
                        'str',
                        all_info['formulae'][token]['tap'],
                    )
                    if all_info['formulae'][token]['installed']:
                        check = 'brew'
                        brew_apps[brew_tap] = [
                            *(
                                brew_apps.get(
                                    brew_tap,
                                    [],
                                )
                            ),
                            (app_path, token),
                        ]
                    else:
                        check = 'has_brew'
                        has_brew_apps[brew_tap] = [
                            *(
                                has_brew_apps.get(
                                    brew_tap,
                                    [],
                                )
                            ),
                            (app_path, token),
                        ]
                if check == 'no_cask':
                    no_cask.append(app_path)
                apps_check[check][d] += 1
                napps += 1

        # Make list
        casks_in_others = []
        output = ''

        output += '# Cask applications\n\n'

        for tap in set(cask_apps.keys()) or set(has_cask_apps.keys()):
            output += f'# Apps installed by cask in {tap}\n'
            if tap != self.opt['cask_repo'] or not self.opt['api']:
                output += f'tap {tap}\n'
            for app_path, token in sorted(cask_apps[tap], key=lambda x: x[1]):
                if token not in casks_in_others:
                    output += self.make_cask_app_cmd(token, app_path) + '\n'
                    casks_in_others.append(token)
                else:
                    output += f'#{self.make_cask_app_cmd(token, app_path)}\n'
            output += '\n'

            if non_latest_cask_apps.get(tap):
                output += '# New version are available for following apps\n'
                for app_path, token in sorted(non_latest_cask_apps[tap]):
                    if token not in casks_in_others:
                        output += (
                            self.make_cask_app_cmd(token, app_path) + '\n'
                        )
                        casks_in_others.append(token)
                    else:
                        output += (
                            f'#{self.make_cask_app_cmd(token, app_path)}\n'
                        )
                output += '\n'

            if installed_casks.get(tap):
                output += '# Cask is found, but no applications are found (could be fonts, system settings, or installed in other directory.)\n'
                for token in sorted(installed_casks[tap]):
                    if token not in casks_in_others:
                        output += f'cask {token}\n'
                        casks_in_others.append(token)
                    else:
                        output += f'#cask {token}\n'
                output += '\n'

            if has_cask_apps.get(tap):
                output += '# Apps installed directly instead of by cask\n'
                for app_path, token in sorted(has_cask_apps[tap]):
                    output += f'#{self.make_cask_app_cmd(token, app_path)}\n'
                output += '\n'

        for tap in set(brew_apps.keys()) or set(has_brew_apps.keys()):
            output += f'# Apps installed by brew in {tap}\n'
            if tap != self.opt['core_repo'] or not self.opt['api']:
                output += f'tap {tap}\n'
            for app_path, token in sorted(brew_apps[tap], key=lambda x: x[1]):
                if token not in casks_in_others:
                    output += self.make_brew_app_cmd(token, app_path) + '\n'
                    casks_in_others.append(token)
                else:
                    output += f'#{self.make_brew_app_cmd(token, app_path)}\n'
            output += '\n'

            if has_brew_apps.get(tap):
                output += '# Apps installed directly instead of by brew\n'
                for app_path, token in sorted(has_brew_apps[tap]):
                    output += f'#{self.make_brew_app_cmd(token, app_path)}\n'
                output += '\n'

        if appstore_apps:
            output += '# Apps installed from AppStore\n'
            for name, app_path in appstore_apps.items():
                output += self.make_appstore_app_cmd(name, app_path) + '\n'
            output += '\n'

        if appstore_has_cask_apps:
            output += (
                '# Apps installed from AppStore, but casks are available.\n'
            )
            for name, (token, app_path) in appstore_has_cask_apps.items():
                output += (
                    self.make_appstore_app_cmd(name, f'{token}, {app_path}')
                    + '\n'
                )
            output += '\n'

        if no_cask:
            output += '# Apps installed but no casks are available\n'
            output += '# (System applications or directory installed.)\n'
            for app_path in no_cask:
                output += f'# {app_path}\n'

        with Path('Caskfile').open('w') as f:
            f.write(output)
        self.log.debug(output)

        # Summary
        self.banner('# Summary')
        self.log.info(
            f'Total:{napps} apps have been checked.\n'
            f'Apps in {[home_tilde(d) for d in app_dirs]}\n',
        )
        maxlen = max(len(home_tilde(x)) for x in app_dirs)
        if sum(apps_check['cask'].values()) > 0:
            self.log.info('Installed by Cask:')
            for d in app_dirs:
                if apps_check['cask'][d] == 0:
                    continue
                self.log.info(
                    f'{home_tilde(d):{maxlen}s} : {apps_check["cask"][d]}',
                )
            self.log.info('')
        if sum(apps_check['brew'].values()) > 0:
            self.log.info('Installed by brew install command')
            for d in app_dirs:
                if apps_check['brew'][d] == 0:
                    continue
                self.log.info(
                    f'{home_tilde(d):{maxlen}s} : {apps_check["brew"][d]}',
                )
            self.log.info('')
        if sum(apps_check['has_cask'].values()) > 0:
            self.log.info('Installed directly, but casks are available:')
            for d in app_dirs:
                if apps_check['has_cask'][d] == 0:
                    continue
                self.log.info(
                    f'{home_tilde(d):{maxlen}s} : {apps_check["has_cask"][d]}',
                )
            self.log.info('')
        if sum(apps_check['appstore'].values()) > 0:
            self.log.info('Installed from Appstore')
            for d in app_dirs:
                if apps_check['appstore'][d] == 0:
                    continue
                self.log.info(
                    f'{home_tilde(d):{maxlen}s} : {apps_check["appstore"][d]}',
                )
            self.log.info('')
        if sum(apps_check['no_cask'].values()) > 0:
            self.log.info('No casks')
            for d in app_dirs:
                if apps_check['no_cask'][d] == 0:
                    continue
                self.log.info(
                    f'{home_tilde(d):{maxlen}s} : {apps_check["no_cask"][d]}',
                )
            self.log.info('')

    def execute(self) -> None:
        """Execute."""
        # Cask list check
        if self.opt['command'] == 'casklist':
            self.check_cask()
            return

        # Set BREWFILE repository
        if self.opt['command'] == 'set_repo':
            _ = self.set_brewfile_repo()
            return

        # Set BREWFILE to local file
        if self.opt['command'] == 'set_local':
            self.set_brewfile_local()
            return

        # Change brewfile if it is repository's one or not.
        self.check_repo()

        # Do pull/push for the repository.
        if self.opt['command'] in ['pull', 'push']:
            with self.DryrunBanner(self):
                self.repomgr(self.opt['command'])
            return

        # brew command
        if self.opt['command'] == 'brew':
            with self.DryrunBanner(self):
                self.brew_cmd()
            return

        # Initialize
        if self.opt['command'] in ['init', 'dump']:
            _ = self.initialize()
            return

        # Edit
        if self.opt['command'] == 'edit':
            self.edit_brewfile()
            return

        # Cat
        if self.opt['command'] == 'cat':
            self.cat_brewfile()
            return

        # Get files
        if self.opt['command'] == 'get_files':
            self.get_files(is_print=True, all_files=self.opt['all_files'])
            return

        # Check input file
        # If the file doesn't exist, initialize it.
        self.check_input_file()

        # Cleanup non request
        if self.opt['command'] == 'clean_non_request':
            with self.DryrunBanner(self):
                self.clean_non_request()
            return

        # Cleanup
        if self.opt['command'] == 'clean':
            with self.DryrunBanner(self):
                self.cleanup()
            return

        # Install
        if self.opt['command'] == 'install':
            with self.DryrunBanner(self):
                self.install()
            return

        # Update
        if self.opt['command'] == 'update':
            with self.DryrunBanner(self):
                if not self.opt['noupgradeatupdate']:
                    _ = self.helper.proc(
                        'brew update',
                        dryrun=self.opt['dryrun'],
                    )
                    fetch_head = (
                        '--fetch-HEAD' if self.opt['fetch_head'] else ''
                    )
                    _ = self.helper.proc(
                        f'brew upgrade --formula {fetch_head}',
                        dryrun=self.opt['dryrun'],
                    )
                    if is_mac():
                        _ = self.helper.proc(
                            'brew upgrade --cask',
                            dryrun=self.opt['dryrun'],
                        )
                if self.opt['repo'] != '':
                    self.repomgr('pull')
                self.install()
                self.cleanup(delete_cache=False)
                if not self.opt['dryrun']:
                    _ = self.initialize(check=False, debug_out=True)
                if self.opt['repo'] != '':
                    self.repomgr('push')
            return

        # No command found
        msg = (
            f'Wrong command: {self.opt["command"]}\n'
            f'Execute `{__prog__} help` for more information.'
        )
        raise RuntimeError(msg)


def main() -> int:
    log = logging.getLogger(__name__.split('.')[0])
    log.setLevel(logging.INFO)
    ch = logging.StreamHandler(stream=sys.stdout)
    ch.setLevel(logging.DEBUG)
    ch.setFormatter(LogFormatter())
    log.addHandler(ch)

    # Prepare BrewFile
    b = BrewFile()

    # Pre Parser
    arg_parser_opts: dict[str, Any] = {
        'add_help': False,
        'allow_abbrev': False,
    }
    pre_parser = argparse.ArgumentParser(
        usage=f'{__prog__}...',
        **arg_parser_opts,
    )
    group = pre_parser.add_mutually_exclusive_group()
    group.add_argument(
        '-i',
        '--init',
        action='store_const',
        dest='command',
        const='init',
    )
    group.add_argument(
        '-s',
        '--set-repo',
        '--set_repo',
        action='store_const',
        dest='command',
        const='set_repo',
    )
    group.add_argument(
        '--set-local',
        '--set_local',
        action='store_const',
        dest='command',
        const='set_local',
    )
    group.add_argument(
        '-c',
        '--clean',
        action='store_const',
        dest='command',
        const='clean',
    )
    group.add_argument(
        '-u',
        '--update',
        action='store_const',
        dest='command',
        const='update',
    )
    group.add_argument(
        '-e',
        '--edit',
        action='store_const',
        dest='command',
        const='edit',
    )
    group.add_argument(
        '--cat',
        action='store_const',
        dest='command',
        const='cat',
    )
    group.add_argument(
        '--commands',
        action='store_const',
        dest='command',
        const='commands',
    )
    group.add_argument(
        '-v',
        '--version',
        action='store_const',
        dest='command',
        const='version',
    )

    # Parent parser
    file_parser = argparse.ArgumentParser(**arg_parser_opts)
    file_parser.add_argument(
        '-f',
        '--file',
        action='store',
        dest='input',
        default=b.opt['input'],
        help='Set input file (default: %(default)s). '
        'You can set input file by environmental variable, '
        'HOMEBREW_BREWFILE, like:\n'
        '    export HOMEBREW_BREWFILE=~/.brewfile',
    )

    backup_parser = argparse.ArgumentParser(**arg_parser_opts)
    backup_parser.add_argument(
        '-b',
        '--backup',
        action='store',
        dest='backup',
        default=b.opt['backup'],
        help='Set backup file (default: %(default)s). '
        'If it is empty, no backup is made. '
        'You can set backup file by environmental variable, '
        'HOMEBREW_BREWFILE_BACKUP, like:\n'
        '    export HOMEBREW_BREWFILE_BACKUP=~/brewfile.backup',
    )

    format_parser = argparse.ArgumentParser(**arg_parser_opts)
    format_parser.add_argument(
        '-F',
        '--format',
        '--form',
        action='store',
        dest='form',
        default=b.opt['form'],
        help='Set input file format (default: %(default)s). \n'
        'file (or none)    : brew vim --HEAD --with-lua\n'
        "brewdler or bundle: brew 'vim', args: ['with-lua', 'HEAD']\n"
        '  Compatible with '
        '[homebrew-bundle]'
        '(https://github.com/Homebrew/homebrew-bundle).\n'
        'command or cmd    : brew install vim --HEAD --with-lua\n'
        '  Can be used as a shell script.\n',
    )

    leaves_parser = argparse.ArgumentParser(**arg_parser_opts)
    leaves_parser.add_argument(
        '--leaves',
        action='store_true',
        dest='leaves',
        default=b.opt['leaves'],
        help='Make list only for leaves (taken by `brew leaves`). '
        'You can set this by environmental variable, '
        'HOMEBREW_BREWFILE_LEAVES, like:\n'
        '    export HOMEBREW_BREWFILE_LEAVES=1',
    )

    on_request_parser = argparse.ArgumentParser(**arg_parser_opts)
    on_request_parser.add_argument(
        '--on-request',
        '--on_request',
        action='store_true',
        dest='on_request',
        default=b.opt['on_request'],
        help='Make list only for packages installed on request. '
        "This option is given priority over 'leaves'. "
        'You can set this by environmental variable, '
        'HOMEBREW_BREWFILE_ON_REQUEST, like:\n'
        '    export HOMEBREW_BREWFILE_ON_REQUEST=1',
    )

    top_packages_parser = argparse.ArgumentParser(**arg_parser_opts)
    top_packages_parser.add_argument(
        '--top-packages',
        '--top_packages',
        action='store',
        dest='top_packages',
        default=b.opt['top_packages'],
        help='Packages to be listed even if they are under dependencies '
        "and `leaves`/'on_request' option is used. "
        'You can set this by environmental variable, '
        "HOMEBREW_BREWFILE_TOP_PACKAGES (',' separated), like:\n"
        '    export HOMEBREW_BREWFILE_TOP_PACKAGES=go,coreutils',
    )

    full_name_parser = argparse.ArgumentParser(**arg_parser_opts)
    full_name_parser.add_argument(
        '--full-name',
        '--full_name',
        action='store_true',
        dest='full_name',
        default=b.opt['full_name'],
        help='Use full names (tap/package) for packages. '
        'You can set this by environmental variable, '
        'HOMEBREW_BREWFILE_FULL_NAME, like:\n'
        '    export HOMEBREW_BREWFILE_FULL_NAME=1',
    )

    noupgradeatupdate_parser = argparse.ArgumentParser(**arg_parser_opts)
    noupgradeatupdate_parser.add_argument(
        '-U',
        '--noupgrade',
        action='store_true',
        dest='noupgradeatupdate',
        default=b.opt['noupgradeatupdate'],
        help='Do not execute `brew update/brew upgrade`'
        ' at `brew file update`.',
    )

    repo_parser = argparse.ArgumentParser(**arg_parser_opts)
    repo_parser.add_argument(
        '-r',
        '--repo',
        action='store',
        dest='repo',
        default=b.opt['repo'],
        help='Set repository name. Use with set_repo.',
    )

    no_repo_parser = argparse.ArgumentParser(**arg_parser_opts)
    no_repo_parser.add_argument(
        '--no-repo',
        '--no_repo',
        action='store_true',
        dest='no_repo',
        default=b.opt['no_repo'],
        help='Do not ask if setting repository when initialize Brewfile.',
    )

    fetch_parser = argparse.ArgumentParser(**arg_parser_opts)
    fetch_parser.add_argument(
        '--fetch-HEAD',
        '--fetch_HEAD',
        action='store_true',
        dest='fetch_head',
        default=b.opt['fetch_head'],
        help='Fetch HEAD at update.',
    )

    link_parser = argparse.ArgumentParser(**arg_parser_opts)
    link_parser.add_argument(
        '-n',
        '--nolink',
        action='store_false',
        dest='link',
        default=b.opt['link'],
        help="Don't make links for Apps.",
    )

    caskonly_parser = argparse.ArgumentParser(**arg_parser_opts)
    caskonly_parser.add_argument(
        '--caskonly',
        action='store_true',
        dest='caskonly',
        default=b.opt['caskonly'],
        help='Write out only cask related packages',
    )

    appstore_parser = argparse.ArgumentParser(**arg_parser_opts)
    appstore_parser.add_argument(
        '--appstore',
        action='store',
        dest='appstore',
        default=b.opt['appstore'],
        help='Set AppStore application check level.\n'
        '0: do not check,\n'
        '1: check and manage,\n'
        '2: check for installation, but do not add to Brewfile when Apps are added. '
        'You can set the level by environmental variable:\n'
        '    export HOMEBREW_BREWFILE_APPSTORE=0',
    )

    no_appstore_parser = argparse.ArgumentParser(**arg_parser_opts)
    no_appstore_parser.add_argument(
        '--no-appstore',
        '--no_appstore',
        action='store_true',
        dest='no_appstore',
        default=b.opt['no_appstore'],
        help='Set AppStore application check level to 0. '
        "(legacy option, works same as '--appstore 0'.)",
    )

    all_files_parser = argparse.ArgumentParser(**arg_parser_opts)
    all_files_parser.add_argument(
        '--all-files',
        '--all_files',
        action='store_true',
        dest='all_files',
        default=b.opt['all_files'],
        help='Show all Brewfile files including non-existing files.',
    )

    dryrun_parser = argparse.ArgumentParser(**arg_parser_opts)
    dryrun_parser.add_argument(
        '-d',
        '--dry-run',
        '--dry_run',
        action='store_true',
        dest='dryrun',
        default=b.opt['dryrun'],
        help='Set dry run mode.',
    )

    yn_parser = argparse.ArgumentParser(**arg_parser_opts)
    yn_parser.add_argument(
        '-y',
        '--yes',
        action='store_true',
        dest='yn',
        default=b.opt['yn'],
        help='Answer yes to all yes/no questions.',
    )

    verbose_parser = argparse.ArgumentParser(**arg_parser_opts)
    verbose_parser.add_argument(
        '-V',
        '--verbose',
        action='store',
        choices=[
            'debug',
            'info',
            'warning',
            'error',
            'critical',
        ],
        dest='verbose',
        default=b.opt['verbose'],
        help='Verbose level',
    )

    help_parser = argparse.ArgumentParser(**arg_parser_opts)
    help_parser.add_argument(
        '-h',
        '--help',
        action='store_true',
        dest='help',
        default=False,
        help='Print Help (this message) and exit.',
    )

    min_parsers = [
        file_parser,
        backup_parser,
        format_parser,
        leaves_parser,
        on_request_parser,
        top_packages_parser,
        full_name_parser,
        no_repo_parser,
        appstore_parser,
        no_appstore_parser,
        caskonly_parser,
        yn_parser,
        verbose_parser,
    ]
    formatter = argparse.RawTextHelpFormatter
    subparser_opts: dict[str, Any] = {
        'formatter_class': formatter,
        'allow_abbrev': False,
    }

    # Main parser
    parser = argparse.ArgumentParser(
        prog=__prog__,
        parents=[
            file_parser,
            backup_parser,
            format_parser,
            leaves_parser,
            on_request_parser,
            top_packages_parser,
            full_name_parser,
            noupgradeatupdate_parser,
            repo_parser,
            no_repo_parser,
            fetch_parser,
            link_parser,
            caskonly_parser,
            appstore_parser,
            no_appstore_parser,
            dryrun_parser,
            yn_parser,
            verbose_parser,
            help_parser,
        ],
        formatter_class=formatter,
        description=__description__,
        epilog='Check https://homebrew-file.readthedocs.io for more details.',
        **arg_parser_opts,
    )

    subparsers = parser.add_subparsers(
        title='subcommands',
        metavar='[command]',
        help='',
        dest='command',
    )

    help_doc = (
        'Install packages in BREWFILE if no <package> is given. '
        'If <package> is given, the package is installed and it is added in BREWFILE.'
    )
    subparsers.add_parser(
        'install',
        description=help_doc,
        help=help_doc,
        parents=[*min_parsers, dryrun_parser],
        **subparser_opts,
    )
    help_doc = (
        'Execute brew command, and update BREWFILE. '
        "Use 'brew noinit <brew command>' to suppress Brewfile initialization."
    )
    subparsers.add_parser(
        'brew',
        description=help_doc,
        help=help_doc,
        parents=min_parsers,
        **subparser_opts,
    )
    help_doc = (
        'or dump/-i/--init\n'
        'Initialize/Update BREWFILE with installed packages.'
    )
    subparsers.add_parser(
        'init',
        description=help_doc,
        help=help_doc,
        parents=[*min_parsers, link_parser, repo_parser],
        **subparser_opts,
    )
    subparsers.add_parser(
        'dump',
        parents=[*min_parsers, link_parser, repo_parser],
        **subparser_opts,
    )
    help_doc = (
        'or -s/--set_repo\n'
        'Set BREWFILE repository (e.g. rcmdnk/Brewfile or full path to your repository).'
    )
    subparsers.add_parser(
        'set_repo',
        description=help_doc,
        help=help_doc,
        parents=[*min_parsers, repo_parser],
        **subparser_opts,
    )
    help_doc = 'or --set_local\nSet BREWFILE to local file.'
    subparsers.add_parser(
        'set_local',
        description=help_doc,
        help=help_doc,
        parents=min_parsers,
        **subparser_opts,
    )
    help_doc = 'Update BREWFILE from the repository.'
    subparsers.add_parser(
        'pull',
        description=help_doc,
        help=help_doc,
        parents=[*min_parsers, dryrun_parser],
        **subparser_opts,
    )
    help_doc = 'Push your BREWFILE to the repository.'
    subparsers.add_parser(
        'push',
        description=help_doc,
        help=help_doc,
        parents=[*min_parsers, dryrun_parser],
        **subparser_opts,
    )
    help_doc = (
        'or -c/--clean\n'
        'Cleanup. Uninstall packages not in the list. Untap packages not in the list. Cleanup cache (brew cleanup and delete rm -rf $(brew --cache)).'
    )
    subparsers.add_parser(
        'clean',
        description=help_doc,
        help=help_doc,
        parents=[*min_parsers, dryrun_parser],
        **subparser_opts,
    )
    help_doc = (
        'or --clean_non_request.\n'
        'Uninstall packages which were installed as dependencies but parent packages of which were already uninstalled (sameas `brew autoremove`).'
    )
    subparsers.add_parser(
        'clean_non_request',
        description=help_doc,
        help=help_doc,
        parents=[*min_parsers, dryrun_parser],
        **subparser_opts,
    )
    help_doc = (
        'or -u/--update\n'
        'Do brew update/upgrade, cask upgrade, pull, install, init and push. In addition, pull and push will be done if the repository is assigned.\nIt will enforce the state recorded in the Brewfile, potentially removing packages installed without `brew-wrap`. If you want to keep all packages in the system, you should better to run `brew file init` before running `brew file update`.'
    )
    subparsers.add_parser(
        'update',
        description=help_doc,
        help=help_doc,
        parents=[
            *min_parsers,
            fetch_parser,
            link_parser,
            noupgradeatupdate_parser,
            dryrun_parser,
        ],
        **subparser_opts,
    )
    help_doc = 'or -e/--edit\nEdit input files.'
    subparsers.add_parser(
        'edit',
        description=help_doc,
        help=help_doc,
        parents=[file_parser],
        **subparser_opts,
    )
    help_doc = 'or --cat\nShow contents of input files.'
    subparsers.add_parser(
        'cat',
        description=help_doc,
        help=help_doc,
        parents=[file_parser],
        **subparser_opts,
    )
    help_doc = 'Check applications for Cask.'
    subparsers.add_parser(
        'casklist',
        description=help_doc,
        help=help_doc,
        parents=[verbose_parser],
        **subparser_opts,
    )
    help_doc = "Get Brewfile's full path, including additional files."
    subparsers.add_parser(
        'get_files',
        description=help_doc,
        help=help_doc,
        parents=[file_parser, all_files_parser],
        **subparser_opts,
    )
    help_doc = 'or --commands\nShow commands.'
    subparsers.add_parser(
        'commands',
        description=help_doc,
        help=help_doc,
        **subparser_opts,
    )
    help_doc = 'or -v/--version\nShow version.'
    subparsers.add_parser(
        'version',
        description=help_doc,
        help=help_doc,
        **subparser_opts,
    )
    help_doc = 'or -h/--help\nPrint Help (this message) and exit.'
    subparsers.add_parser(
        'help',
        description=help_doc,
        help=help_doc,
        **subparser_opts,
    )

    info = f'{parser.format_usage()}\n\nExecute `{__prog__} help` to get help.\n\nRefer https://homebrew-file.readthedocs.io for more details.'
    if len(sys.argv) == 1:
        log.info(info)
        return 0

    if sys.argv[1] == 'brew':
        args = sys.argv[1:]
    else:
        (ns, args) = pre_parser.parse_known_args()
        if ns.command is not None:
            args = [ns.command, *args]
        else:
            for a in args[:]:
                if a in subparsers.choices:
                    args.remove(a)
                    args = [a, *args]
                    break
        if args[0] in ['-h', '--help']:
            args[0] = 'help'
    (ns, args_tmp) = parser.parse_known_args(args)
    args_dict = vars(ns)
    args_dict.update({'args': args_tmp})
    if args_dict['command'] is None:
        log.warning('Need command')
        log.info(info)
        return 1
    if args_dict['command'] in ('install') and args_dict['args']:
        cmd = args_dict['command']
        args_dict['command'] = 'brew'
        args_dict['args'].insert(0, cmd)

    b.set_args(**args_dict)

    if b.opt['command'] == 'help':
        log.info(parser.format_help())
        return 0
    if b.opt['command'] == 'brew':
        if args_tmp and args_tmp[0] in ['-h', '--help']:
            log.info(subparsers.choices[b.opt['command']].format_help())
            return 0
    elif 'help' in args_tmp:
        log.info(subparsers.choices[b.opt['command']].format_help())
        return 0
    elif b.opt['command'] == 'commands':
        commands = [
            'install',
            'brew',
            'init',
            'dump',
            'set_repo',
            'set_local',
            'pull',
            'push',
            'clean',
            'clean_non_request',
            'update',
            'edit',
            'cat',
            'casklist',
            'get_files',
            'commands',
            'version',
            'help',
        ]
        commands_hyphen = [
            '-i',
            '--init',
            '-s',
            '--set_repo',
            '--set_local',
            '-c',
            '--clean',
            '--clean_non_request',
            '-u',
            '--update',
            '-e',
            '--edit',
            '--cat',
            '--commands',
            '-v',
            '--version',
            '-h',
            '--help',
        ]
        options = [
            '-f',
            '--file',
            '-b',
            '--backup',
            '-F',
            '--format',
            '--form',
            '--leaves',
            '--on_request',
            '--top_packages',
            '-U',
            '--noupgrade',
            '-r',
            '--repo',
            '--fetch-HEAD',
            '-n',
            '--nolink',
            '--caskonly',
            '--appstore',
            '--no_appstore',
            '--all_files',
            '-d',
            '--dry_run',
            '-y',
            '--yes',
            '-V',
            '--verbose',
        ]
        log.info(
            f'commands: {" ".join(commands)}\n'
            f'commands_hyphen: {"".join(commands_hyphen)}\n'
            f'options: {" ".join(options)}',
        )
        return 0
    elif b.opt['command'] == 'version':
        b.helper.proc('brew -v', print_cmd=False)
        log.info(f'{__prog__} {__version__} {__date__}')
        return 0

    try:
        b.execute()
    except KeyboardInterrupt:
        return 1
    except CmdError as e:
        b.log.exception('')
        return e.return_code
    except RuntimeError:
        b.log.exception('')
        return 1
    return 0


if __name__ == '__main__':
    sys.exit(main())
