#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Brew-file: Manager for packages of Homebrew
https://github.com/rcmdnk/homebrew-file

requirement: Python 2.7 or later
"""

__prog__ = "brew file"
__author__ = "rcmdnk"
__copyright__ = "Copyright (c) 2013 rcmdnk"
__credits__ = ["rcmdnk"]
__license__ = "MIT"
__version__ = "v3.5.2"
__date__ = "2/Jun/2015"
__maintainer__ = "rcmdnk"
__email__ = "rcmdnk@gmail.com"
__status__ = "Prototype"

import os
import sys


class Tee:
    """Module to write out in two ways at once."""

    def __init__(self, out1, out2=sys.stdout, use2=True):
        from cStringIO import StringIO
        if type(out1) == str:
            self.out1name = out1
            self.out1 = StringIO()
        else:
            self.out1name = ""
            self.out1 = out1
        self.use2 = use2
        if self.use2:
            if type(out2) == str:
                self.out2name = out2
                self.out2 = StringIO()
            else:
                self.out2name = ""
                self.out2 = out2

    def __del__(self):
        if self.out1name != "":
            self.out1.close()
        if self.use2:
            if self.out2name != "":
                self.out2.close()

    def write(self, text):
        self.out1.write(text)
        if self.use2:
            self.out2.write(text)

    def writeln(self, text):
        self.out1.write(text + "\n")
        if self.use2:
            self.out2.write(text + "\n")

    def flush(self):
        self.out1.flush()
        if self.use2:
            self.out2.flush()

    def close(self):
        if self.out1name != "":
            f = open(self.out1name, "w")
            f.write(self.out1.getvalue())
            f.close()
        if self.use2:
            if self.out2name != "":
                f = open(self.out2name, "w")
                f.write(self.out2.getvalue())
                f.close()
        self.__del__()


class BrewHelper:
    """Helper functions for BrewFile."""

    def __init__(self, opt):
        self.opt = opt

    def proc(self, cmd, print_cmd=True, print_out=True,
             exit_on_error=True, verbose_level=1):
        """ Get process output."""
        import shlex
        import subprocess
        if type(cmd) == str:
            cmd = shlex.split(cmd)
        if cmd[0] == "brew":
            cmd = ["command"] + cmd
        if print_cmd:
            self.info('$ ' + ' '.join(cmd), verbose_level)
        p = subprocess.Popen(cmd, stdout=subprocess.PIPE,
                             stderr=subprocess.STDOUT)
        lines = []
        for l in iter(p.stdout.readline, ''):
            lines.append(l.rstrip())
            if print_out:
                self.info(l.strip(), verbose_level)
        ret = p.wait()

        if exit_on_error and ret != 0:
            if not (print_out and self.opt["verbose"] >= verbose_level):
                print '\n'.join(lines)
            sys.exit(ret)

        return (ret, lines)

    def info(self, text, verbose_level=2):
        if self.opt["verbose"] < verbose_level:
            return
        print text

    def warning(self, text, verbose_level=1):
        self.info("\033[31;1m" + text + "\033[m", verbose_level)

    def banner(self, text, verbose_level=2):
        max = 0
        for l in text.split("\n"):
            if max < len(l):
                max = len(l)
        self.info("\n"+"#"*max+"\n"+text+"\n" + "#"*max+"\n", verbose_level)


class BrewInfo:
    """Homebrew information storage."""

    def __init__(self, helper, filename=''):

        self.brew_input_opt = {}

        self.brew_input = []
        self.tap_input = []
        self.cask_input = []
        self.pip_input = []
        self.appstore_input = []
        self.file_input = []

        self.before_input = []
        self.after_input = []
        self.cmd_input = []

        self.brew_list_opt = {}

        self.brew_list = []
        self.tap_list = []
        self.cask_list = []
        self.pip_list = []
        self.appstore_list = []
        self.file_list = []

        self.tap_packs = []
        self.tap_casks = []
        self.cask_nocask_list = []

        self.list_dic = {
            "brew_input_opt": self.brew_input_opt,
            "brew_input": self.brew_input,
            "tap_input": self.tap_input,
            "cask_input": self.cask_input,
            "pip_input": self.pip_input,
            "appstore_input": self.appstore_input,
            "file_input": self.file_input,
            "before_input": self.before_input,
            "after_input": self.after_input,
            "cmd_input": self.cmd_input,
            "brew_list_opt": self.brew_list_opt,
            "brew_list": self.brew_list,
            "tap_list": self.tap_list,
            "cask_list": self.cask_list,
            "cask_nocask_list": self.cask_nocask_list,
            "pip_list": self.pip_list,
            "appstore_list": self.appstore_list,
            "file_list": self.file_list,
            "tap_packs": self.tap_packs,
            "tap_casks": self.tap_casks,
        }
        self.filename = filename
        self.helper = helper

    def set_file(self, filename):
        self.filename = filename

    def get_file(self):
        return self.filename

    def get_dir(self):
        return os.path.dirname(self.filename)

    def check_file(self):
        if os.path.exists(self.filename):
            return True
        else:
            return False

    def check_dir(self):
        if os.path.exists(self.get_dir()):
            return True
        else:
            return False

    def clear(self):
        self.clear_input()
        self.clear_list()

        del self.tap_packs[:]
        del self.tap_casks[:]

    def clear_input(self):
        self.brew_input_opt.clear()

        del self.brew_input[:]
        del self.tap_input[:]
        del self.cask_input[:]
        del self.pip_input[:]
        del self.appstore_input[:]
        del self.file_input[:]

        del self.before_input[:]
        del self.after_input[:]
        del self.cmd_input[:]

    def clear_list(self):
        self.brew_list_opt.clear()

        del self.brew_list[:]
        del self.tap_list[:]
        del self.cask_list[:]
        del self.cask_nocask_list[:]
        del self.pip_list[:]
        del self.appstore_list[:]
        del self.file_list[:]

    def input_to_list(self):
        self.clear_list()
        self.brew_list.extend(self.brew_input)
        self.brew_list_opt.update(self.brew_input_opt)
        self.tap_list.extend(self.tap_input)
        self.cask_list.extend(self.cask_input)
        self.pip_list.extend(self.pip_input)
        self.appstore_list.extend(self.appstore_input)
        self.file_list.extend(self.file_input)

    def get(self, name):
        return self.list_dic[name]

    def remove(self, name, package):
        if type(self.list_dic[name]) == list:
            self.list_dic[name].remove(package)
        elif type(self.list_dic[name]) == dict:
            del self.list_dic[name][package]

    def set_val(self, name, val):
        if type(self.list_dic[name]) == list:
            del self.list_dic[name][:]
            self.list_dic[name].extend(val)
        elif type(self.list_dic[name]) == dict:
            self.list_dic[name].clear()
            self.list_dic[name].update(val)

    def add(self, name, val):
        if type(self.list_dic[name]) == list:
            self.list_dic[name].extend(val)
        elif type(self.list_dic[name]) == dict:
            self.list_dic[name].update(val)

    def read(self, filename=''):
        self.clear_input()

        try:
            if filename == '':
                f = open(self.filename, "r")
            else:
                f = open(filename, "r")
        except IOError:
            return False

        lines = f.readlines()
        f.close()
        import re
        for l in lines:
            if re.match(" *$", l) is not None or\
                    re.match(" *#", l) is not None:
                continue
            args = l.replace("'", "").replace('"', "").\
                replace(",", " ").replace("[", "").replace("]", "").split()
            cmd = args[0]
            p = args[1] if len(args) > 1 else ""
            if len(args) > 2 and p == "install":
                p = args[2]
                args.pop(1)
            if len(args) > 2:
                if args[2] == "args:":
                    opt = " " + " ".join(["--" + x for x in args[3:]]).strip()
                else:
                    opt = " " + " ".join(args[2:]).strip()
            else:
                opt = ""
            excmd = " ".join(l.split()[1:]).strip()

            if cmd == "brew" or cmd == "install":
                self.brew_input.append(p)
                self.brew_input_opt[p] = (opt)
            elif cmd == "tap":
                self.tap_input.append(p)
            elif cmd == "tapall":
                self.tap_input.append(p)
                self.get_tap(p)
                for tp in self.tap_packs:
                    self.brew_input.append(tp)
                    self.brew_input_opt[tp] = ""
            elif cmd == "cask":
                self.cask_input.append(p)
            elif cmd == "pip":
                self.pip_input.append(p)
            elif cmd == "appstore":
                self.appstore_input.append(p + opt)
            elif cmd == "file" or cmd.lower() == "brewfile":
                self.file_input.append(p)
            elif cmd == "before":
                self.before_input.append(excmd)
            elif cmd == "after":
                self.after_input.append(excmd)
            else:
                self.cmd_input.append(l.strip())

    def get_tap_path(self, tap):
        """Get tap path"""
        tap_user = os.path.dirname(tap)
        tap_repo = os.path.basename(tap)
        return self.helper.opt["tap_dir"] + "/" +\
            tap_user + "/homebrew-" + tap_repo

    def get_tap(self, tap):
        """Helper for tap configuration file"""
        tap_path = self.get_tap_path(tap)
        if not os.path.isdir(tap_path):
            return
        self.set_val("tap_packs", map(lambda x: x.replace(".rb", ""),
                                      filter(lambda y: y.endswith(".rb"),
                                             os.listdir(tap_path))))
        path = tap_path + "/Formula"
        if os.path.isdir(path):
            self.add("tap_packs", map(lambda x: x.replace(".rb", ""),
                                      filter(lambda y: y.endswith(".rb"),
                                             os.listdir(path))))
        path = tap_path + "/Casks"
        if os.path.isdir(path):
            self.set_val("tap_casks",
                         map(lambda x: x.replace(".rb", ""),
                             filter(lambda y: y.endswith(".rb"),
                                    os.listdir(tap_path + "/Casks"))))

    def packout(self, pack):
        if self.helper.opt["form"] == "brewdler":
            return "'" + pack + "'"
        else:
            return pack

    def get_options(self, package):
        """get install options from brew info"""

        opt = ""
        # Get options for build
        (ret, lines) = self.helper.proc("brew info " + package, False, False)
        versions = {"stable": "", "devel": "", "HEAD": ""}
        v_tmp = map(lambda x: x.strip().split(),
                    lines[0].split(":")[1].split(","))
        for v in v_tmp:
            if v[0] == "stable":
                versions["stable"] = v[1]
            elif v[0] == "devel":
                versions["devel"] = v[1]
            elif v[0] == "HEAD":
                versions["HEAD"] = "HEAD"
        cellar = self.helper.proc("brew --cellar " + package,
                                  False, False)[1][0]
        for l in lines:
            ltmp = l.split("Built from source with: ")
            if len(ltmp) > 1:
                opt += " " + ltmp[1].replace(",", "")
                continue
            if l.startswith(cellar):
                v = l.split()[0].split("/")[-1]
                for k in versions.keys():
                    if v == versions[k]:
                        if k != "stable":
                            opt += " --" + k
                        break
        if opt != "" and self.helper.opt["form"] == "brewdler":
            import re
            opt = ", args: [" + ", ".join(
                ["'" + re.sub("^--", "", x) + "'" for x in opt.split()]) + "]"
        return opt

    def write(self, check_opt=True):
        # Prepare output
        out = Tee(self.get_file(), sys.stdout, self.helper.opt["verbose"] > 1)

        # Before commands
        if len(self.before_input) > 0:
            out.writeln("# Before commands")
            for p in self.before_input:
                out.writeln("before " + p)

        # Taps
        if len(self.tap_list) > 0:
            out.writeln("\n# tap repositories and their packages")
            for p in self.tap_list:
                self.get_tap(p)
                out.writeln("\n## " + p + "\ntap " + self.packout(p))
                for tp in self.tap_packs:
                    if tp in self.brew_list:
                        if check_opt:
                            pack = self.packout(tp) + self.get_options(tp)
                        else:
                            pack = self.packout(tp) + self.brew_list_opt[tp]
                        out.writeln("brew " + pack)
                        self.brew_list.remove(tp)
                        del self.brew_list_opt[tp]
                for tc in self.tap_casks:
                    if tc in self.cask_list:
                        out.writeln("cask " + self.packout(tc))
                        self.cask_list.remove(tc)

        # Brew packages
        if len(self.brew_list) > 0:
            out.writeln("\n# Other Homebrew packages")
            for p in self.brew_list:
                if check_opt:
                    pack = self.packout(p) + self.get_options(p)
                else:
                    pack = self.packout(p) + self.brew_list_opt[p]
                out.writeln("brew " + pack)

        # pip packages
        if len(self.pip_list) > 0:
            out.writeln("\n# pip packages")
            for p in self.pip_list:
                out.writeln("pip " + self.packout(p))

        # Casks
        if len(self.cask_list) > 0:
            out.writeln("\n# Cask applications")
            for p in self.cask_list:
                out.writeln("cask " + self.packout(p))

        # Installed by cask, but cask files were not found...
        if len(self.cask_nocask_list) > 0:
            out.writeln("\n# Below applications were installed by Cask,")
            out.writeln("# but do not have corresponding casks.\n")
            for p in self.cask_nocask_list:
                out.writeln("#cask " + self.packout(p))

        # App Store applications
        if len(self.appstore_list) > 0:
            out.writeln("\n# App Store applications")
            for p in self.appstore_list:
                if self.helper.opt["form"] == "brewdler":
                    out.writeln("#appstore " + self.packout(p))
                else:
                    out.writeln("appstore " + self.packout(p))

        # Additional files
        if len(self.file_list) > 0:
            out.writeln("\n# Additional files")
            for p in self.file_list:
                if self.helper.opt["form"] == "brewdler":
                    out.writeln("#file " + self.packout(p))
                else:
                    out.writeln("file " + self.packout(p))

        # Other commands
        if len(self.cmd_input) > 0:
            out.writeln("\n# Other commands")
            for p in self.cmd_input:
                out.writeln(p)

        # After commands
        if len(self.after_input) > 0:
            out.writeln("\n# After commands")
            for p in self.after_input:
                out.writeln("after " + p)

        # Close Brewfile
        out.close()


class BrewFile:

    """Main class of Brew-file."""

    def __init__(self):
        """initialization."""

        # Set default values
        self.opt = {}

        # Prepare helper, need verbose first
        self.opt["verbose"] = int(os.environ.get("HOMEBREW_FILE_VERBOSE", 1))
        self.helper = BrewHelper(self.opt)

        # First check Homebrew
        self.check_brew_cmd()

        # Other default values
        self.opt["command"] = ""
        self.opt["brew_repo"] =\
            self.proc(
                "brew --prefix", False, False, True, 0)[1][0]
        self.opt["input"] = os.environ.get("HOMEBREW_BREWFILE",
                                           self.opt["brew_repo"] +
                                           "/Library/Brewfile")
        self.opt["form"] = "file"
        self.opt["repo"] = ""
        self.opt["noupdate"] = False
        self.opt["link"] = True
        self.opt["dryrun"] = True
        self.opt["initialized"] = False
        self.opt["tap_dir"] = self.opt["brew_repo"] + "/Library/Taps"
        self.opt["cache_dir"] = self.proc(
            "brew --cache", False, False, True, 0)[1][0]
        self.opt["cask_pack"] = "brew-cask"
        self.opt["cask_repo"] = "caskroom/cask"
        self.opt["pip_pack"] = "brew-pip"
        self.opt["my_editor"] = os.environ.get("EDITOR", "vim")
        self.opt["is_brew_cmd"] = False
        self.opt["is_cask_cmd"] = False
        self.opt["is_pip_cmd"] = False
        self.opt["args"] = []
        self.opt["yn"] = False

        # Check HOMEBREW_CASK_OPTS
        import re
        cask_opts = {"--caskroom": "", "--appdir": ""}
        env_cask_opts = os.environ.get("HOMEBREW_CASK_OPTS", "")
        try:
            if env_cask_opts != "":
                cask_opts.update(
                    dict(map(lambda x: x.split("="),
                             re.split(r'(?<!\\)\s*', env_cask_opts))))
        except ValueError:
            self.warning("HOMEBREW_CASK_OPTS: " + env_cask_opts +
                         " is not a proper format.", 0)
            self.warning("Ignore the value.\n", 0)
        self.opt["caskroom"] = cask_opts["--caskroom"] \
            if cask_opts["--caskroom"] != "" \
            else "/opt/homebrew-cask/Caskroom"
        self.opt["appdir"] = cask_opts["--appdir"].rstrip("/") \
            if cask_opts["--appdir"] != ""\
            else os.environ["HOME"]+"/Applications"
        self.opt["appdirlist"] = ["/Applications",
                                  os.environ["HOME"] + "/Applications"]
        if self.opt["appdir"].rstrip("/") not in self.opt["appdirlist"]:
            self.opt["appdirlist"].append(self.opt["appdir"])
        self.opt["appdirlist"] += [x.rstrip("/") + "/Utilities"
                                   for x in self.opt["appdirlist"]]
        self.opt["appdirlist"] = [x for x in self.opt["appdirlist"]
                                  if os.path.isdir(x)]

        self.opt["float_test"] = 0.0

        self.int_opts = ["verbose"]
        self.float_opts = ["float_test"]

        self.brewinfo = BrewInfo(self.helper, self.opt["input"])
        self.brewinfo_ext = []

    def set_args(self, **kw):
        """Set arguments."""
        for k, v in kw.items():
            self.opt[k] = v

        for k in self.int_opts:
            self.opt[k] = int(self.opt[k])
        for k in self.float_opts:
            self.opt[k] = float(self.opt[k])

        self.brewinfo.set_file(self.opt["input"])

    def ask_yn(self, question): # pragma: no cover
        """Helper for yes/no."""
        if self.opt["yn"]:
            print question + " [y/n]: y"
            return True

        yes = ["yes", "y", ""]
        no = ["no", "n"]

        yn = raw_input(question + " [y/n]: ").lower()
        while True:
            if yn in yes:
                return True
            elif yn in no:
                return False
            else:
                yn = raw_input("Answer with yes (y) or no (n): ").lower()

    def verbose(self):
        try:
            v = self.opt["verbose"]
        except: # pragma: no cover
            v = 10
        return v

    def proc(self, cmd, print_cmd=True, print_out=True,
             exit_on_error=True, verbose_level=1):
        return self.helper.proc(
            cmd=cmd, print_cmd=print_cmd, print_out=print_out,
            exit_on_error=exit_on_error, verbose_level=verbose_level)

    def info(self, text, verbose_level=2):
        self.helper.info(text, verbose_level)

    def warning(self, text, verbose_level=1):
        self.helper.warning(text, verbose_level)

    def banner(self, text, verbose_level=2):
        self.helper.banner(text, verbose_level)

    def remove(self, path):
        """Helper to remove file/directory."""
        import shutil
        if os.path.islink(path) or os.path.isfile(path):
            os.remove(path)
        elif os.path.isdir(path):
            shutil.rmtree(path)
        else:
            self.warning("Tried to remove non usual file/directory:" + path, 0)

    def read(self, brewinfo):
        brewinfo.read()
        for f in brewinfo.get("file_input"):
            f = os.path.expandvars(os.path.expanduser(f))
            if os.path.isabs(f):
                b = BrewInfo(self.helper, f)
            else:
                b = BrewInfo(self.helper, brewinfo.get_dir() + "/" + f)
            self.brewinfo_ext.append(b)
            self.read(b)

    def input_to_list(self, only_ext=False):
        if not only_ext:
            self.brewinfo.input_to_list()
        for b in self.brewinfo_ext:
            b.input_to_list()

    def write(self, check_opt=True):
        self.banner("# Initialize " + self.brewinfo.get_file(), 1)
        self.brewinfo.write(check_opt=check_opt)
        for b in self.brewinfo_ext:
            self.banner("# Initialize " + b.get_file(), 1)
            b.write(check_opt=check_opt)

    def get(self, name):
        import copy
        l = copy.deepcopy(self.brewinfo.get(name))
        if type(l) == list:
            for b in self.brewinfo_ext:
                l += b.get(name)
        elif type(l) == dict:
            for b in self.brewinfo_ext:
                l.update(b.get(name))
        return l

    def remove_pack(self, name, package):
        if package in self.brewinfo.get(name):
            self.brewinfo.remove(name, package)
        else:
            for b in self.brewinfo_ext:
                if package in b.get(name):
                    b.remove(name, package)

    def repo_file(self):
        """Helper to build Brewfile path for the repository."""
        repo_name = self.opt["repo"].split("/")[-1].split(".git")[0]
        user_name = self.opt["repo"].split("/")[-2].split(":")[-1]
        input = self.opt["input"].split("/")[-1]
        return self.opt["brew_repo"] + "/Library/" + user_name + "_" +\
            repo_name + "/" + input

    def clone_repo(self):
        ret = self.proc("git clone " + self.opt["repo"] + " " +
                        self.brewinfo.get_dir(),
                        True, True, False)[0]
        if ret != 0: # pragma: no cover
            self.warning(
                "can't clone " + self.opt["repo"] + ".\n"
                "please check the repository, or reset with\n"
                "    $ " + __prog__ + " set_repo", 0)
            sys.exit(ret)

    def check_github_repo(self): # pragma: no cover
        """helper to check and create GitHub repository."""
        import urllib2

        repo_name = self.opt["repo"].split("/")[-1].split(".git")[0]
        user_name = self.opt["repo"].split("/")[-2].split(":")[-1]
        url = "https://github.com/" + user_name + "/" + repo_name

        # Check if the repository already exists or not.
        exist_repo = True
        try:
            urllib2.urlopen(url)
        except urllib2.HTTPError:
            exist_repo = False

        # Clone if exists
        if exist_repo:
            self.clone_repo()
            return

        # Create new repository #
        print "GitHub repository: " + user_name + "/" + repo_name +\
              " doesn't exist."
        ans = self.ask_yn("do you want to create the repository?")
        if not ans:
            exit(0)

        # Try to create w/o two-factor code
        try:
            import requests
        except ImportError:
            print "To create a repository, " +\
                  "you need to install 'requests' module."
            ans = self.ask_yn("Do you want to install now?")
            if not ans:
                print "Please prepare Brewfile repository."
                exit(0)
            else:
                ret = self.proc("pip --version", False, False, False)
                if not ret:
                    self.proc("easy_install pip")
                self.proc("pip install requests")
                print "Now please run `brew file set_repo` again."
                exit(0)

        import json
        url = "https://api.github.com/user/repos"
        description = "package list for Homebrew"
        data = {"name": repo_name, "description": description,
                "auto_init": "true"}
        headers = {}
        is_ok = True

        # Check password
        import getpass
        password = getpass.getpass("GitHub password: ")

        while True:
            r = requests.post(url=url, data=json.dumps(data),
                              auth=(user_name, password), headers=headers)
            if r.ok:
                break
            if r.json()["message"] == "Bad credentials":
                password = getpass.getpass(
                    "\033[31;1mWrong password!\033[0m GitHub password: ")
                continue
            if r.json()["message"] ==\
                    "Must specify two-factor authentication OTP code.":
                is_ok = False
                break
            self.err(r.json()["message"])
            sys.exit(1)

        if not is_ok:
            # Try with two-factor code
            twofac = raw_input("GitHub two-factor code: ")
            headers.update({"X-Github-OTP": twofac})
            while True:
                r = requests.post(url=url, data=json.dumps(data),
                                  auth=(user_name, password), headers=headers)
                if r.ok:
                    break
                if r.json()["message"] ==\
                        "Must specify two-factor authentication OTP code.":
                    twofac = getpass.getpass("\033[31;1mWrong code!\033[0m "
                                             "GitHub two-factor code: ")
                    headers.update({"X-Github-OTP": twofac})
                    continue
                self.warning(r.json()["message"], 0)
                sys.exit(1)

        # Clone and initialize
        self.clone_repo()
        os.chdir(self.brewinfo.get_dir())
        f = open("README.md", "w")
        f.write("# " + repo_name + "\n\n"
                "Package list for [homebrew](http://brew.sh/).\n\n"
                "Managed by "
                "[homebrew-file](https://github.com/rcmdnk/homebrew-file).")
        f.close()
        open(self.brewinfo.get_file(), "a").close()

        self.proc("git add -A")[0]
        self.proc(["git", "commit", "-m",
                   "\"Prepared by " + __prog__ + "\""])[0]
        self.proc("git push")[0]

        ans = self.ask_yn("Do you want to initialize from installed packages?")
        if ans:
            self.initialize(False)

    def check_repo(self):
        """Check input file for GitHub repository."""
        import re
        self.brewinfo.set_file(self.opt["input"])

        # Check input file
        if not os.path.exists(self.opt["input"]):
            return

        # Check input file if it points repository or not
        self.opt["repo"] = ""
        f = open(self.opt["input"], "r")
        lines = f.readlines()
        f.close()
        for l in lines:
            if re.match(" *git ", l) is None:
                continue
            git_line = l.split()
            if len(git_line) > 1:
                self.opt["repo"] = git_line[1]
                break
        if self.opt["repo"] == "":
            return

        # Check repository name and add git@github.com: if necessary
        if (re.match("git://", self.opt["repo"]) is None and
                re.match("git@", self.opt["repo"]) is None and
                re.match("https?://", self.opt["repo"]) is None):
            self.opt["repo"] = "git@github.com:" + self.opt["repo"]

        # Set Brewfile in the repository
        self.brewinfo.set_file(self.repo_file())
        if self.brewinfo.check_file():
            return

        # Check and prepare repository
        if self.opt["repo"].find("github") >= 0:
            self.check_github_repo()
        else:
            self.clone_repo()

    def repomgr(self, cmd=""):
        """Helper of repository management."""
        pull = False
        push = False
        if cmd == "pull":
            pull = True
            push = False
        elif cmd == "push":
            pull = False
            push = True

        # Check the repository
        if self.opt["repo"] == "":
            self.warning("Please set a repository, or reset with:", 0)
            self.warning("    $ " + __prog__ + "set_repo\n", 0)
            sys.exit(1)

        # Clone if it doesn't exist
        if not self.brewinfo.check_dir():
            self.clone_repo()

        # pull/push
        self.info("cd " + self.brewinfo.get_dir(), 1)
        os.chdir(self.brewinfo.get_dir())
        if pull:
            self.proc("git pull")[0]
            return
        elif push:
            self.proc("git add " + self.brewinfo.get_file().split("/")[-1])[0]
            self.proc(["git", "commit", "-m", "\"Update the package list\""],
                      exit_on_error=False)[0]
            self.proc("git push")[0]
            return

    def brew_cmd(self):
        noinit = False
        if len(self.opt["args"]) > 0:
            if "noinit" in self.opt["args"]:
                noinit = True
                self.opt["args"].pop(0)
        (ret, lines) = self.proc(["brew"] + self.opt["args"],
                                 True, True, False)
        if ret != 0 or noinit or len(self.opt["args"]) < 2 or\
                (self.opt["args"][1] == "cask" and len(self.opt["args"]) < 3):
            sys.exit(ret)
        if self.brewinfo.check_file():
            self.read(self.brewinfo)
        cmd = self.opt["args"][0]
        p = self.opt["args"][1]
        if cmd == "install":
            psplit = p.split("/")
            if len(psplit) > 2:
                p = psplit[2]
                if p in self.get("brew_input"):
                    self.warning(p + " is already in Brewfile.")
                    self.warning("Do 'brew file init' to clean up Brewfile")
                    sys.exit(0)
                if len(self.opt["args"]) > 2:
                    self.brewinfo.brew_input_opt[p] =\
                        " " + " ".join(self.opt["args"][2:]).strip()
                else:
                    self.brewinfo.brew_input_opt[p] = ""
                t = psplit[0] + "/" + psplit[1]
                if t not in self.get("tap_input"):
                    self.brewinfo.tap_input.append(psplit[0] + "/" + psplit[1])
                    self.brewinfo.tap_input.sort()
            elif p in self.get("brew_input"):
                self.warning(p + " is already in Brewfile.")
                self.warning("Do 'brew file init' to clean up Brewfile")
                sys.exit(0)
            self.brewinfo.brew_input.append(p)
            self.brewinfo.brew_input.sort()
            if len(self.opt["args"]) > 2:
                self.brewinfo.brew_input_opt[p] =\
                    " " + " ".join(self.opt["args"][2:]).strip()
            else:
                self.brewinfo.brew_input_opt[p] = ""
        elif cmd == "tap":
            if p in self.get("tap_input"):
                self.warning(p + " is already in Brewfile.")
                self.warning("Do 'brew file init' to clean up Brewfile")
                sys.exit(0)
            self.brewinfo.tap_input.append(p)
            self.brewinfo.tap_input.sort()
        elif cmd == "rm" or cmd == "remove" or cmd == "uninstall":
            if p not in self.get("brew_input"):
                self.warning(p + " is not in Brewfile.")
                self.warning("Do 'brew file init' to clean up Brewfile")
                sys.exit(0)
            self.remove_pack("brew_input", p)
            self.remove_pack("brew_input_opt", p)
        elif cmd == "untap":
            if p not in self.get("tap_input"):
                self.warning(p + " is not in Brewfile.")
                self.warning("Do 'brew file init' to clean up Brewfile")
                sys.exit(0)
            self.remove_pack("tap_input", p)
        elif cmd == "cask":
            cmd = self.opt["args"][1]
            p = self.opt["args"][2]
            if cmd == "install":
                if p in self.get("cask_input"):
                    self.warning(p + " is already in Brewfile.")
                    self.warning("Do 'brew file init' to clean up Brewfile")
                    sys.exit(0)
                self.brewinfo.cask_input.append(p)
                self.brewinfo.cask_input.sort()
            if cmd == "rm" or cmd == "remove" or cmd == "uninstall":
                if p not in self.get("cask_input"):
                    self.warning(p + " is not in Brewfile.")
                    self.warning("Do 'brew file init' to clean up Brewfile")
                    sys.exit(0)
                self.remove_pack("cask_input", p)
        else:
            # Not install/remove command, no init.
            sys.exit(0)

        self.input_to_list()
        self.initialize_write(check_opt=False)

    def check_brew_cmd(self): # pragma: no cover
        """Check Homebrew"""
        if self.proc("which brew", False, False, False, 0)[0] != 0:
            print "Homebrew has not been installed, install now..."
            cmd = "curl -O https://raw.githubusercontent.com/" +\
                  "Homebrew/install/master/install"
            self.proc(cmd, True, True, False, 0)
            cmd = "ruby install"
            self.proc(cmd, True, True, False, 0)
            (ret, lines) = self.proc("brew doctor",
                                     True, True, False, 0)
            if ret != 0:
                for l in lines:
                    sys.stdout.write(l)
                print
                self.warning("\nCheck brew environment and fix problems\n"
                             "# You can check with:\n"
                             "#     $ brew doctor", 0)

    def check_cask_cmd(self, force=False):
        """Check cask is installed or not"""
        if self.opt["is_cask_cmd"]:
            return True
        if self.proc("brew cask", False, False, False)[0] == 0:
            self.opt["is_cask_cmd"] = True
            return True
        if force:
            print self.opt["cask_pack"] +\
                " has not been installed, install now."
            ret = self.proc(
                ["brew", "install",
                 self.opt["cask_repo"] + "/" + self.opt["cask_pack"]],
                True, True, False)[0]
            if ret != 0: # pragma: no cover
                self.warning("\nFailed to install " +
                             self.opt["cask_pack"] + "\n", 0)
                sys.exit(ret)
            if not self.opt["cask_repo"] in self.get("tap_list"):
                self.brewinfo.tap_list.append(self.opt["cask_repo"])
            if not self.opt["cask_pack"] in self.get("brew_list"):
                self.brewinfo.brew_list.append(self.opt["cask_pack"])
                self.brewinfo.brew_list_opt[self.opt["cask_pack"]] = ""
            self.opt["is_cask_cmd"] = True
        return self.opt["is_cask_cmd"]

    def check_pip_cmd(self, force=False):
        """Check pip is installed or not"""
        if self.opt["is_pip_cmd"]:
            return True
        if self.proc("brew pip -h", False, False, False)[0] == 0:
            self.opt["is_pip_cmd"] = True
            return True
        if force:
            print self.opt["pip_pack"] +\
                " has not been installed, install now."
            ret = self.proc(["brew", "install", self.opt["pip_pack"]],
                            True, True, False)[0]
            if ret != 0: # pragma: no cover
                self.warning("\nFailed to install " +
                             self.opt["pip_pack"] + "\n", 0)
                sys.exit(ret)
            if not self.opt["pip_pack"] in self.get("brew_list"):
                self.brewinfo.brew_list.append(self.opt["pip_pack"])
                self.brewinfo.brew_list_opt[self.opt["pip_pack"]] = ""
            self.opt["is_pip_cmd"] = True
        return self.opt["is_pip_cmd"]

    def get_appstore_list(self):
        """Get AppStore Application List"""

        import glob
        apps = []
        for d in self.opt["appdirlist"]:
            apps += [x.split("/")[-4].split(".app")[0] for x in
                     glob.glob(d + '/*/Contents/_MASReceipt/receipt')]
        return apps

    def get_list(self):
        """Get List"""

        # Clear lists
        self.brewinfo.clear_list()

        # Brew packages
        (ret, lines) = self.proc("brew list", False, False)
        for p in lines:
            if p.startswith("pip-"):
                self.brewinfo.pip_list.append(p)
            else:
                self.brewinfo.brew_list.append(p)
                self.brewinfo.brew_list_opt[p] = ""

        # Taps
        (ret, lines) = self.proc("brew tap", False, False)
        self.brewinfo.set_val("tap_list", lines)

        # Casks
        if self.check_cask_cmd():
            (ret, lines) = self.proc("brew cask list", False, False)
            if ret == 0 and len(lines) > 0\
                    and lines[0].find("nothing to list") == -1:
                for p in lines:
                    if len(p.split()) == 1:
                        self.brewinfo.cask_list.append(p)
                    else:
                        self.warning("The cask file of " + p +
                                     " doesn't exist.", 0)
                        self.warning("Please check later.\n\n", 0)
                        self.brewinfo.cask_nocask_list.append(p)

        # App Store
        self.brewinfo.set_val("appstore_list", self.get_appstore_list())

    def clean_list(self):
        """Remove duplications between brewinfo.list to extra files' input"""

        # Cleanup extra files
        for b in self.brewinfo_ext:
            for l in ["brew", "tap", "cask", "pip", "appstore", "file"]:
                for p in b.get(l+"_input"):
                    if p not in self.brewinfo.get(l+"_list"):
                        b.remove(l+"_input", p)

        # Copy input to list for extra files.
        self.input_to_list(only_ext=True)

        # Loop over lists to remove duplications.
        # tap_list is not checked for overlap removal.
        # Keep it in main list in any case.
        for l in ["brew", "cask", "cask_nocask", "pip", "appstore", "file"]:
            if l == "cask_nocask":
                i = "cask"
            else:
                i = l
            for p in self.brewinfo.get(l+"_list"):
                if p not in self.brewinfo.get(i+"_input") and\
                        p in self.get(i+"_input"):
                    self.brewinfo.remove(l+"_list", p)

    def set_brewfile_repo(self):
        """Set Brewfile repository"""
        import re

        # Check input file
        if os.path.exists(self.opt["input"]):
            prev_repo = ""
            f = open(self.opt["input"], "r")
            lines = f.readlines()
            f.close()
            for l in lines:
                if re.match(" *git ", l) is None:
                    continue
                git_line = l.split()
                if len(git_line) > 1:
                    prev_repo = git_line[1]
                    break
            print "Input file: " + self.opt["input"] + " is already there."
            if prev_repo != "":
                print "git repository for Brewfile is already set as " +\
                    prev_repo

            ans = self.ask_yn("Do you want to overwrite it?")
            if ans:
                os.rename(self.opt["input"], self.opt["input"] + ".bak")
                self.info("Ok, old input file was moved to " +
                          self.opt["input"] + ".bak.", 1)
            else:
                sys.exit(0)

        # Get repository
        if self.opt["repo"] == "": # pragma: no cover
            print "Set repository, \"non\" for local Brewfile,"
            print "<user>/<repo> for github repository,"
            self.opt["repo"] = raw_input("or full path for the repository: ")
            while True:
                if self.opt["repo"] != "":
                    break
                print "Repository can not be empty"
                self.opt["repo"] = raw_input("Set repository: ")
            self.banner("# Set Brewfile repository as " +
                        self.opt["repo"])

        if self.opt["repo"] == "non": # pragma: no cover
            # Reset non repository type Brewfile
            self.initialize(False)
            return
        else:
            # Write repository to the input file
            f = open(self.opt["input"], "w")
            f.write("git " + self.opt["repo"])
            f.close()
            self.check_repo()

    def initialize(self, check=True):
        """Initialize Brewfile"""
        if self.opt["initialized"]:
            return

        if check == 1:
            if not os.path.exists(self.opt["input"]):
                ans = self.ask_yn("Do you want to set a repository (y)? " +
                                  "((n) for local Brewfile).")
                if ans:
                    self.set_brewfile_repo()
                    return
            else:
                if self.opt["repo"] != "":
                    print "You are using Brewfile of " + self.opt["repo"] + "."
                else:
                    print self.opt["input"] + " is already there."

                ans = self.ask_yn("Do you want to overwrite it?")
                if ans:
                    if self.opt["repo"] == "":
                        os.rename(self.opt["input"],
                                  self.opt["input"] + ".bak")
                        self.info("Ok, old input file was moved to " +
                                  self.opt["input"] + ".bak.", 1)
                else:
                    sys.exit(0)

        # Get installed package list
        self.get_list()

        # Read inputs
        if self.brewinfo.check_file():
            self.read(self.brewinfo)

        # Remove duplications between brewinfo.list to extra files' input
        self.clean_list()

        # write out
        self.initialize_write()

    def initialize_write(self, check_opt=True):
        self.write(check_opt=check_opt)
        self.banner("# You can edit " + self.brewinfo.get_file() + " with:\n"
                    "#     $ " + __prog__ + " edit")
        self.opt["initialized"] = True

    def check_input_file(self):
        """Check input file"""

        if not self.brewinfo.check_file():
            self.warning(
                "Input file " + self.brewinfo.get_file() + " is not found.", 0)
            ans = self.ask_yn(
                "Do you want to initialize from installed packages?")
            if ans:
                self.initialize(False)
                return
            else:
                self.warning("Ok, please prepare brewfile", 0)
                self.warning("or you can initialize " +
                             self.brewinfo.get_file() + " with:", 0)
                self.warning("    $ " + __prog__ + " init", 0)
                sys.exit(1)

    def edit_brewfile(self):
        """Edit brewfile"""
        import subprocess
        subprocess.call([self.opt["my_editor"], self.brewinfo.get_file()])

    def cleanup(self):
        """Clean up."""
        if self.opt["dryrun"]:
            self.banner("# Dry run")

        # Check up packages in the input file
        self.read(self.brewinfo)

        # Clean up App Store applications
        if len(self.get("appstore_list")) > 0: # pragma: no cover
            self.banner("# Clean up App Store applications")
            cmd = "sudo uninstall"
            n_uninstall = 0
            import urllib2
            for p in self.get("appstore_list"):
                if p in self.get("appstore_input"):
                    continue
                tmpcmd = cmd
                for d in self.opt["appdirlist"]:
                    if os.path.isdir(d + p + ".app"):
                        cmd += " file:///" + urllib2.quote(d + p + ".app")
                        continue
                if cmd == tmpcmd:
                    continue
                n_uninstall += 1
                if self.opt["dryrun"]:
                    print cmd
                self.remove_pack("appstore_list", p)
            if not self.opt["dryrun"] and n_uninstall > 0:
                self.proc(cmd, True, True, False)

        # Clean up cask packages
        if len(self.get("cask_list")) > 0:
            self.banner("# Clean up cask packages")
            for p in self.get("cask_list"):
                if p in self.get("cask_input"):
                    continue
                self.check_cask_cmd(True)
                cmd = "brew cask uninstall " + p
                if self.opt["dryrun"]:
                    print cmd
                else:
                    self.proc(cmd, True, True)
                self.remove_pack("cask_list", p)

        # Skip clean up cask at tap/brew if any cask packages exist
        if len(self.get("cask_list")) > 0:
            self.remove_pack("tap_list", self.opt["cask_repo"])
            self.remove_pack("brew_list", self.opt["cask_pack"])
            self.remove_pack("brew_list_opt", self.opt["cask_pack"])

        # Clean up pip packages
        if len(self.get("pip_list")) > 0:
            self.banner("# Clean up pip packages")
            for p in self.get("pip_list"):
                if p in self.get("pip_input"):
                    continue
                cmd0 = "pip uninstall -y " + p
                cmd1 = "brew uninstall " + p
                cmd2 = "brew uninstall pip-" + p
                if self.opt["dryrun"]:
                    print cmd0
                    print cmd1
                    print cmd2
                else:
                    self.proc(cmd0, True, True, False)
                    self.proc(cmd1, True, True, False)
                    self.proc(cmd2, True, True, False)
                self.remove_pack("pip_list", p)
        # Skip clean up cask at tap/brew if any cask packages exist
        if len(self.get("pip_list")) > 0:
            self.remove_pack("brew_list", self.opt["pip_pack"])
            self.remove_pack("brew_list_opt", self.opt["pip_pack"])

        # Clean up tap packages
        if len(self.get("tap_list")) > 0:
            self.banner("# Clean up tap packages")
            for p in self.get("tap_list"):
                if p in self.get("tap_input"):
                    continue
                self.brewinfo.get_tap(p)
                untapflag = True
                for tp in self.brewinfo.tap_packs:
                    if tp in self.get("brew_input"):
                        # Keep the Tap as related package is remained
                        untapflag = False
                        break
                if not untapflag:
                    continue
                cmd = "brew untap " + p
                if self.opt["dryrun"]:
                    print cmd
                else:
                    self.proc(cmd, True, True)

        # Clean up brew packages
        if len(self.get("brew_list")) > 0:
            self.banner("# Clean up brew packages")
            for p in self.get("brew_list"):
                if p in self.get("brew_input"):
                    continue
                cmd = "brew uninstall " + p
                if self.opt["dryrun"]:
                    print cmd
                else:
                    # (ret, lines) = self.proc("brew info " + p, False, False)
                    # for l in lines:
                    #     if l.find("ln -s") >= 0:
                    #         if len(l.split()) > 2:
                    #             app = l.split()[2]
                    #             break
                    # for d in self.opt["appdirlist"]:
                    #     self.remove(d + app)

                    self.proc(cmd, False, True)

        # Clean up cashe
        self.banner("# Clean up cache")
        cmd0 = "brew cleanup --force"
        cmd1 = "rm -rf " + self.opt["cache_dir"]
        if self.opt["dryrun"]:
            print cmd0
            print cmd1
            # Dry run message
            self.banner("# This is dry run.\n"
                        "# If you want to enforce cleanup, use '-C':\n"
                        "#     $ " + __prog__ + " clean -C", 0)
        else:
            self.proc(cmd0, False)
            self.proc(cmd1, False)

    def install(self):
        """Install"""
        # First update Homebrew
        if not self.opt["noupdate"]:
            self.proc("brew update")

        # Check packages in the input file
        self.read(self.brewinfo)

        # before commands
        for c in self.get("before_input"):
            self.proc(c)

        # Tap
        for p in self.get("tap_input"):
            if p not in self.get("tap_list"):
                self.proc("brew tap " + p)

        # Cask
        for p in self.get("cask_input"):
            if p not in self.get("cask_list"):
                self.check_cask_cmd(True)
                self.proc("brew cask install " + p)

        # pip
        for p in self.get("pip_input"):
            if p not in self.get("pip_list"):
                self.check_pip_cmd(True)
                self.proc("brew pip " + p)

        # Brew
        for p in self.get("brew_input"):
            if p not in self.get("brew_list"):
                (ret, lines) = self.proc("brew install " + p +
                                         self.get("brew_input_opt")[p])
                for l in lines:
                    if l.find("ln -s") >= 0:
                        if self.opt["link"]:
                            self.proc(l)
                    if l.find("brew linkapps") >= 0:
                        if self.opt["link"]:
                            self.proc("brew linkapps")

        # App Store
        for p in self.get("appstore_input"):
            if p not in self.get("appstore_list"):
                self.warning("\nPlease install " + p + " from App Store!", 0)

        # Other commands
        for c in self.get("cmd_input"):
            self.proc(c)

        # after commands
        for c in self.get("after_input"):
            self.proc(c)

        return 0

    def find_app(self, app, taps, casks, nonapp_casks,
                 casks_noinst, nonapp_casks_noinst):
        """Helper function for Cask"""
        self.check_cask_cmd(True)
        [cask_user, cask_repo_name] = self.opt["cask_repo"].split("/")
        cask_namer = self.brewinfo.get_tap_path(self.opt["cask_repo"]) +\
            "/developer/bin/generate_cask_token"
        name = ""
        lines = self.proc([cask_namer, '"' + app.split("/")[-1].lower() + '"'],
                          False, False, False)[1]
        tap = ""
        for l in lines:
            if l.find("Proposed token") >= 0:
                name = l.split()[2]
            if l.find("already exists") >= 0:
                for t in taps:
                    tname = t.split('/')[0]+"/homebrew-"+t.split('/')[1]
                    if l.split("'")[1].find(tname) >= 0:
                        tap = t
                        break
        if tap == "":
            name = ""

        installed = False
        casks, nonapp_casks, casks_noinst, nonapp_casks_noinst
        if name != "":
            for c in [x for x in casks.values() + nonapp_casks +
                      casks_noinst.values() + nonapp_casks_noinst
                      if x[0] == name]:
                if c[2]:
                    installed = True
        if not installed:
            for c in [x for x in casks.values() + nonapp_casks +
                      casks_noinst.values() + nonapp_casks_noinst]:
                if c[4].find(app+"'") >= 0 or c[4].find(app+"/") >= 0:
                    if c[2]:
                        installed = True
                    if installed or name == "":
                        tap = c[1]
                        name = c[0]
                    if installed:
                        break
                if installed:
                    break
        if name == "":
            self.info("Non Cask app: " + app, 2)
        elif installed:
            self.info("Installed by Cask:" + app + name, 2)
        else:
            self.info("Installed directly, instead of by Cask:" +
                      app + name, 2)
        return (tap, installed, name)

    def find_brew_app(self, name, tap):
        """Helper function for Cask to find app installed by brew install"""

        check = "has_cask"
        tap_brew = tap
        opt = ""
        if os.path.isfile(self.opt["brew_repo"] +
                          "/Library/Formula/" + name + ".rb") and\
                name in self.proc("brew list", False, False)[1]:
            check = "brew"
            opt = self.brewinfo.get_options(name)
            if os.path.islink(self.opt["brew_repo"] +
                              "/Library/Formula/" + name + ".rb"):
                link = os.readlink(self.opt["brew_repo"] +
                                   "/Library/Formula/" + name + ".rb")
                tap_brew = link.replace("../Taps/", "").replace("homebrew-").\
                    replace("/"+name+".rb")
            else:
                tap_brew = ""
        return (check, tap_brew, opt)

    def check_cask(self):
        import re
        """Check applications for Cask"""
        self.check_cask_cmd(True)

        self.banner("# Starting to check applications for Cask...")

        # First, get App Store applications
        self.brewinfo.set_val("appstore_list", self.get_appstore_list())

        # Set cask directories and reset application information list
        taps = filter(
            lambda t: os.path.isdir(self.brewinfo.get_tap_path(t) + "/Casks"),
            self.proc("brew tap", False, False)[1])
        apps = dict([d, {True: [], False: []}]
                    for d in taps + ["", "appstore"])
        brew_apps = {}

        # Set applications directories
        app_dirs = self.opt["appdirlist"]
        apps_check = {"cask": dict([d, 0] for d in app_dirs),
                      "cask_obsolete": dict([d, 0] for d in app_dirs),
                      "has_cask": dict([d, 0] for d in app_dirs),
                      "brew": dict([d, 0] for d in app_dirs),
                      "appstore": dict([d, 0] for d in app_dirs),
                      "no_cask": dict([d, 0] for d in app_dirs)}

        # Load casks
        casks = {}
        nonapp_casks = []
        casks_noinst = {}
        nonapp_casks_noinst = []
        (ret, lines) = self.proc("brew cask list", False, False)
        installed_casks = []
        if ret == 0 and len(lines) > 0\
                and lines[0].find("nothing to list") == -1:
            installed_casks = lines
        for t in taps:
            d = self.brewinfo.get_tap_path(t) + "/Casks"
            for cask in map(
                    lambda x: x.replace(".rb", ""),
                    filter(lambda y: y.endswith(".rb"), os.listdir(d))):
                cask_apps = []
                installed = False
                noinst = True
                if cask in installed_casks:
                    noinst = False
                with open(d + "/" + cask + ".rb", "r") as f:
                    content = f.read()
                for l in content.split('\n'):
                    if re.search("^ *name ", l):
                        cask_apps.append(
                            re.sub("^ *name ", "", l).strip('"\' ')+".app")
                    if re.search("^ *app ", l):
                        cask_apps.append(re.sub("^ *app ", "", l).
                                         strip('"\' ').split('/')[-1])
                    if re.search("^ *pkg ", l):
                        cask_apps.append(re.sub("^ *pkg ", "", l).
                                         strip('"\' ').split('/')[-1].
                                         replace(".pkg", ""))
                    if not noinst and re.search("^ *version ", l):
                        if os.path.isdir(
                                self.opt["caskroom"] + "/" + cask + "/" +
                                re.sub("^ *version ", "", l).strip('"\': ')):
                            installed = True
                if noinst:
                    if len(cask_apps) == 0:
                        nonapp_casks_noinst.append([cask, t, installed,
                                                    False, content])
                    else:
                        for a in cask_apps:
                            casks_noinst[a] = [cask, t, installed,
                                               False, content]
                else:
                    if len(cask_apps) == 0:
                        nonapp_casks.append([cask, t, installed,
                                             False, content])
                    else:
                        for a in cask_apps:
                            casks[a] = [cask, t, installed, False, content]

        # Get applications
        napps = 0
        for d in app_dirs:
            for app in [x for x in os.listdir(d)
                        if not x.startswith(".") and x != "Utilities"]:
                check = "no_cask"
                if app.rstrip(".app") in self.get("appstore_list"):
                    tap = "appstore"
                    installed = False
                    name = ""
                    check = "appstore"
                elif app in ['Mail.app', 'Remote Desktop Connection.app',
                             'Console.app', 'Grab.app', 'Keychain Access.app']:
                    tap = ""
                    installed = False
                    name = ""
                elif app in casks.keys() or\
                        app.split(".")[0] in casks.keys():
                    app_key = app if app in casks.keys() else app.split(".")[0]
                    tap = casks[app_key][1]
                    installed = casks[app_key][2]
                    name = casks[app_key][0]
                    for a in filter(lambda k: casks[k][0] == name,
                                    casks.keys()):
                        casks[a][3] = True
                    casks[app_key][3] = True
                    if installed:
                        check = "cask"
                    elif name != "":
                        installed = True
                        check = "cask_obsolete"
                else:
                    app_find = app
                    if not app.endswith(".app"):
                        app_find = d + "/" + app
                    (tap, installed, name) = self.find_app(
                        app_find, taps, casks, nonapp_casks,
                        casks_noinst, nonapp_casks_noinst)
                    for c in filter(lambda x: x[0] == name, nonapp_casks):
                        nonapp_casks.remove(c)
                    for a in filter(lambda k: casks[k][0] == name,
                                    casks.keys()):
                        casks[a][3] = True
                    if installed:
                        check = "cask"
                    elif name != "":
                        (check, tap, opt) = self.find_brew_app(name, tap)
                if check != "brew":
                    apps[tap][installed].append((name, d + "/" + app, check))
                else:
                    if tap not in brew_apps:
                        brew_apps[tap] = []
                    brew_apps[tap].append((name, d + "/" + app, opt))
                apps_check[check][d] += 1
                napps += 1

        # Make list
        casks_in_others = []
        out = Tee("Caskfile", sys.stdout, self.verbose() > 1)

        out.writeln("# Cask applications")
        out.writeln("# Please copy these lines to your Brewfile"
                    " and use with `" + __prog__ + " install`.\n")

        out.writeln("# Main tap repository for " + self.opt["cask_pack"])
        out.writeln("install " + self.opt["cask_repo"] +
                    "/" + self.opt["cask_pack"])
        out.writeln("")
        if len(apps[self.opt["cask_repo"]][True]) > 0:
            out.writeln("# Apps installed by Cask in " + self.opt["cask_pack"])
            for (name, app_path, check) in\
                    sorted(x for x in apps[self.opt["cask_repo"]][True]
                           if x[2] != "cask_obsolete"):
                if name not in casks_in_others:
                    out.writeln(
                        "cask install " + name +
                        " #" + app_path.replace(os.environ["HOME"], "~"))
                    casks_in_others.append(name)
                else:
                    out.writeln(
                        "#cask install " + name +
                        " #" + app_path.replace(os.environ["HOME"], "~"))

            if len([x for x in apps[self.opt["cask_repo"]][True]
                    if x[2] == "cask_obsolete"]) > 0:
                out.writeln(
                    "# There are new version for following applications.")
                for (name, app_path, check) in\
                        sorted(x for x in apps[self.opt["cask_repo"]][True]
                               if x[2] == "cask_obsolete"):
                    if name not in casks_in_others:
                        out.writeln(
                            "cask install " + name +
                            " #" + app_path.replace(os.environ["HOME"], "~"))
                        casks_in_others.append(name)
                    else:
                        out.writeln(
                            "#cask install " + name +
                            " #" + app_path.replace(os.environ["HOME"], "~"))
            out.writeln("")

        if len([x[0] for x in casks.values() + nonapp_casks
                if x[1] == self.opt["cask_repo"] and not x[3]]) > 0:
            out.writeln("# Cask is found, but no applications are found " +
                        "(could be fonts, system settins, " +
                        "or installed in other directory.")
            for name in sorted(
                    x[0] for x in casks.values() + nonapp_casks
                    if x[1] == self.opt["cask_repo"] and x[2] and not x[3]):
                if name not in casks_in_others:
                    out.writeln("cask install " + name)
                    casks_in_others.append(name)
            if len([x[0] for x in casks.values() + nonapp_casks
                   if x[1] == self.opt["cask_repo"] and
                   not x[2] and not x[3]]) > 0:
                out.writeln(
                    "# There are new version for following applications.")
                for name in sorted(
                        x[0] for x in casks.values() + nonapp_casks
                        if x[1] == self.opt["cask_repo"] and
                        not x[2] and not x[3]):
                    out.writeln("cask install " + name)
            out.writeln("")

        if len(apps[self.opt["cask_repo"]][False]) > 0:
            out.writeln("# Apps installed directly instead of by Cask in " +
                        self.opt["cask_pack"])
            for (name, app_path, check) in\
                    sorted(x for x in apps[self.opt["cask_repo"]][False]):
                out.writeln("#cask install " + name +
                            " #" + app_path.replace(os.environ["HOME"], "~"))
            out.writeln("")

        for t in filter(lambda x: x != self.opt["cask_repo"] and
                        x != "" and x != "appstore", taps):
            out.writeln("# Casks in " + t)
            out.writeln("tap " + t)
            out.writeln("")
            if len(apps[t][True]) > 0:
                out.writeln("# Apps installed by Cask in " + t)
                for (name, app_path, check) in\
                        sorted(x for x in apps[t][True]
                               if x[2] != "cask_obsolete"):
                    if name not in casks_in_others:
                        out.writeln("cask install " + name + " #" +
                                    app_path.replace(os.environ["HOME"], "~"))
                        casks_in_others.append(name)
                    else:
                        out.writeln("#cask install " + name + " #" +
                                    app_path.replace(os.environ["HOME"], "~"))

                if len([x for x in apps[t][True]
                        if x[2] == "cask_obsolete"]) > 0: # pragma: no cover
                    out.writeln(
                        "# There are new version for following applications.")
                    for (name, app_path, check) in\
                            sorted(x for x in apps[t][True]
                                   if x[2] == "cask_obsolete"):
                        if name not in casks_in_others:
                            out.writeln(
                                "cask install " + name + " #" +
                                app_path.replace(os.environ["HOME"], "~"))
                            casks_in_others.append(name)
                        else:
                            out.writeln(
                                "#cask install " + name + " #" +
                                app_path.replace(os.environ["HOME"], "~"))
                out.writeln("")

            if len([x[0] for x in casks.values() + nonapp_casks
                    if x[1] == t and not x[3]]) > 0:
                out.writeln(
                    "# Cask is found, but no applications are found " +
                    "(fonts, system settins, or installed in other directory.")
                for name in sorted(x[0]
                                   for x in casks.values() + nonapp_casks
                                   if x[1] == t and x[2] and not x[3]):
                    if name not in casks_in_others:
                        out.writeln("cask install " + name)
                        casks_in_others.append(name)
                if len([x[0] for x in casks.values() + nonapp_casks
                        if x[1] == t and not x[2] and not x[3]]) > 0:
                    out.writeln(
                        "# There are new version for following applications.")
                    for name in sorted(x[0]
                                       for x in casks.values() + nonapp_casks
                                       if x[1] == t and not x[2] and not x[3]):
                        out.writeln("cask install " + name)
                out.writeln("")

            if len(apps[t][False]) > 0:
                out.writeln(
                    "# Apps installed directly instead of by Cask in " + t)
                for (name, app_path, check) in apps[t][False]:
                        out.writeln("#cask install " + name + " #" +
                                    app_path.replace(os.environ["HOME"], "~"))
                out.writeln("")

        if len(brew_apps.keys()) > 0:
            out.writeln("# Apps installed by brew install command")
            if "" in brew_apps:
                for (name, app_path, opt) in brew_apps[""]:
                    out.writeln("install " + name + " " + opt + " #" +
                                app_path.replace(os.environ["HOME"], "~"))
            for tap in [x for x in brew_apps.keys() if x != ""]:
                out.writeln("tap " + tap)
                for (name, app_path, opt) in brew_apps[tap]:
                    out.writeln("install " + name + " " + opt + " #" +
                                app_path.replace(os.environ["HOME"], "~"))
            out.writeln("")

        if len(apps["appstore"][False]) > 0: # pragma: no cover
            out.writeln("# Apps installed from AppStore")
            for (name, app_path, check) in apps["appstore"][False]:
                    out.writeln("#" + app_path)
            out.writeln("")

        if len(apps[""][False]) > 0:
            out.writeln("# Apps installed but no casks are available")
            out.writeln("# (System applications or directory installed.)")
            for (name, app_path, check) in apps[""][False]:
                    out.writeln("#" + app_path)

        out.close()

        # Summary
        self.banner("# Summary")
        if self.verbose() > 0:
            print "Total:", napps, "apps have been checked."
            print "Apps in", [d.replace(os.environ["HOME"], "~")
                              for d in app_dirs]
            print ""
            maxlen = max(len(x.replace(os.environ["HOME"], "~"))
                         for x in app_dirs)
            if sum(apps_check["cask"].values()) > 0:
                print "Installed by Cask:"
                for d in app_dirs:
                    if apps_check["cask"][d] == 0:
                        continue
                    print "{0:<{1}s} : {2:d}".format(d.replace(
                        os.environ["HOME"], "~"), maxlen,
                        apps_check["cask"][d])
                print ""
            if sum(apps_check["cask_obsolete"].values())\
                    > 0: # pragma: no cover
                print "Installed by Cask (New version is availble, " +\
                    "try `brew file cask_upgrade`):"
                for d in app_dirs:
                    if apps_check["cask_obsolete"][d] == 0:
                        continue
                    print "{0:<{1}s} : {2:d}".format(d.replace(
                        os.environ["HOME"], "~"), maxlen,
                        apps_check["cask_obsolete"][d])
                print ""
            if sum(apps_check["brew"].values()) > 0:
                print "Installed by brew install command"
                for d in app_dirs:
                    if apps_check["brew"][d] == 0:
                        continue
                    print "{0:<{1}s} : {2:d}".format(d.replace(
                        os.environ["HOME"], "~"), maxlen,
                        apps_check["brew"][d])
                print ""
            if sum(apps_check["has_cask"].values()) > 0:
                print "Installed directly, but casks are available:"
                for d in app_dirs:
                    if apps_check["has_cask"][d] == 0:
                        continue
                    print "{0:<{1}s} : {2:d}".format(d.replace(
                        os.environ["HOME"], "~"), maxlen,
                        apps_check["has_cask"][d])
                print ""
            if sum(apps_check["appstore"].values()) > 0: # pragma: no cover
                print "Installed from Appstore"
                for d in app_dirs:
                    if apps_check["appstore"][d] == 0:
                        continue
                    print "{0:<{1}s} : {2:d}".format(d.replace(
                        os.environ["HOME"], "~"), maxlen,
                        apps_check["appstore"][d])
                print ""
            if sum(apps_check["no_cask"].values()) > 0:
                print "No casks"
                for d in app_dirs:
                    if apps_check["no_cask"][d] == 0:
                        continue
                    print "{0:<{1}s} : {2:d}".format(d.replace(
                        os.environ["HOME"], "~"), maxlen,
                        apps_check["no_cask"][d])
                print ""

    def cask_upgrade(self):
        """Upgrade cask applications"""
        if not self.check_cask_cmd():
            return
        apps = self.proc("brew cask list", False, False)[1]
        for a in apps:
            lines = self.proc("brew cask info " + a, False, False)[1]
            installed = True
            for l in lines:
                if l.find("Not installed") >= 0:
                    installed = False
                    break
            if not installed:
                self.proc(["brew", "cask", "install", a])
            if not self.opt["dryrun"]:
                current = ""
                for l in lines:
                    if l.startswith(self.opt["caskroom"]):
                        current = l.split()[0]
                if current == "":
                    continue
                appdir = os.path.dirname(current)
                for d in os.listdir(appdir):
                    if d != current.split("/")[-1]:
                        self.info("rm -rf " + appdir + "/" + d, 1)
                        try:
                            self.remove(appdir + "/" + d)
                        except:
                            if d != "":
                                self.proc("sudo rm -rf " + appdir + "/" + d)

    def my_test(self):
        out = Tee("test")
        out.write("test\n")
        out.close()
        out = Tee(sys.stdout, "test")
        out.write("test\n")
        out.flush()
        out.close()
        self.remove("test")
        os.mkdir("dir")
        self.remove("dir")
        self.remove("aaa")
        self.brewinfo.read()
        print 'read input:', len(self.brewinfo.brew_input)
        self.brewinfo.clear()
        print 'read input cleared:', len(self.brewinfo.brew_input)
        self.brewinfo.set_file('/test/not/correct/file/path')
        self.brewinfo.read()
        self.brewinfo.check_dir()
        self.brewinfo.set_val('brew_input_opt', {"test_pack": "test opt"})
        self.brewinfo.add('brew_input_opt', {"test_pack2": "test opt2"})
        print self.brewinfo.get('brew_input_opt')
        self.brewinfo.read('testfile')
        self.brewinfo.get_tap('/aaa/bbb')

    def execute(self):
        """Main execute function"""
        # Cask list check
        if self.opt["command"] == "casklist":
            self.check_cask()
            sys.exit(0)

        # Upgrade cask applications
        if self.opt["command"] == "cask_upgrade":
            self.cask_upgrade()
            sys.exit(0)

        # Set BREWFILE repository
        if self.opt["command"] == "set_repo":
            self.set_brewfile_repo()
            sys.exit(0)

        # Change brewfile if it is repository's one.
        self.check_repo()

        # Do pull/push for the repository.
        if self.opt["command"] in ["pull", "push"]:
            self.repomgr(self.opt["command"])
            sys.exit(0)

        # brew command
        if self.opt["command"] == "brew":
            self.brew_cmd()
            sys.exit(0)

        # Initialize
        if self.opt["command"] in ["init", "dump"]:
            self.initialize()
            sys.exit(0)

        # Check input file
        # If the file doesn't exist, initialize it.
        self.check_input_file()

        # Edit
        if self.opt["command"] == "edit":
            self.edit_brewfile()
            sys.exit(0)

        # Get list for cleanup/install
        self.get_list()

        # Cleanup
        if self.opt["command"] == "clean":
            self.cleanup()
            sys.exit(0)

        # Install
        if self.opt["command"] == "install":
            self.install()
            sys.exit(0)

        # Update
        if self.opt["command"] == "update":
            if self.opt["repo"] != "":
                self.repomgr("pull")
            self.install()
            self.proc("brew update")
            self.proc("brew upgrade --all")
            self.initialize(False)
            if self.opt["repo"] != "":
                self.repomgr("push")
                self.opt["dryrun"] = False
                self.cleanup()
            sys.exit(0)

        # test
        if self.opt["command"] == "test":
            self.my_test()
            sys.exit(0)

        # No command found
        self.warning("Wrong command: ",
                     self.opt["command"], 0) # pragma: no cover
        self.warning("Execute `" + __prog__ +
                     " help` for more information.", 0) # pragma: no cover
        sys.exit(1) # pragma: no cover


def main():
    # Prepare BrewFile
    b = BrewFile()

    import argparse

    # Pre Parser
    pre_parser = argparse.ArgumentParser(
        add_help=False, usage=__prog__+"...")
    group = pre_parser.add_mutually_exclusive_group()
    group.add_argument("-i", "--init", action="store_const",
                       dest="command", const="init")
    group.add_argument("-s", "--set_repo", action="store_const",
                       dest="command", const="set_repo")
    group.add_argument("-c", "--clean", action="store_const",
                       dest="command", const="clean")
    group.add_argument("-u", "--update", action="store_const",
                       dest="command", const="update")
    group.add_argument("-e", "--edit", action="store_const",
                       dest="command", const="edit")
    group.add_argument("--test", action="store_const",
                       dest="command", const="test")
    group.add_argument("--commands", action="store_const",
                       dest="command", const="commands")
    group.add_argument("-v", "--version", action="store_const",
                       dest="command", const="version")
    group.add_argument("-h", "--help", action="store_const",
                       dest="command", const="help")

    # Parent parser
    file_parser = argparse.ArgumentParser(add_help=False)
    file_parser.add_argument(
        "-f", "--file", action="store", dest="input",
        default=b.opt["input"],
        help="Set input file (default: %(default)s). \n"
              "You can set input file by environmental variable,\n"
              "HOMEBREW_BREWFILE, like:\n"
              "    export HOMEBREW_BREWFILE=~/.brewfile")

    format_parser = argparse.ArgumentParser(add_help=False)
    format_parser.add_argument(
        "-F", "--format", "--form", action="store", dest="form",
        default=b.opt["form"],
        help="Set input file format (default: %(default)s). \n"
              "file:     brew vim --HEAD --with-lua\n"
              "brewdler: brew 'vim', args: ['with-lua', 'HEAD']\n")

    noupdatedummy_parser = argparse.ArgumentParser(add_help=False)
    noupdatedummy_parser.add_argument(
        "-U", "--noupdate", action="store_true",
        default=False, dest="noupdatedummy",
        help="Do not execute `brew update` before install or other commands.")

    noupdate_parser = argparse.ArgumentParser(add_help=False)
    noupdate_parser.add_argument(
        "--preupdate", action="store_false",
        default=True, dest="noupdate",
        help="Execute `brew update` before install or other commands.")

    repo_parser = argparse.ArgumentParser(add_help=False)
    repo_parser.add_argument(
        "-r", "--repo", action="store", default="", dest="repo",
        help="Set repository name. Use with set_repo.")

    link_parser = argparse.ArgumentParser(add_help=False)
    link_parser.add_argument(
        "-n", "--nolink", action="store_false", default=True,
        dest="link", help="Don't make links for Apps.")

    dryrun_parser = argparse.ArgumentParser(add_help=False)
    dryrun_parser.add_argument(
        "-C", action="store_false", default=True,
        dest="dryrun", help="Run cleanup in non dry-run mode.")

    yn_parser = argparse.ArgumentParser(add_help=False)
    yn_parser.add_argument(
        "-y", "--yes", action="store_true", default=False,
        dest="yn", help="Answer yes to all yes/no questions.")

    verbose_parser = argparse.ArgumentParser(add_help=False)
    verbose_parser.add_argument("-V", "--verbose", action="store", default=1,
                                dest="verbose", help="Verbose level 0/1/2")

    subparser_options = {
        "parents": [file_parser, format_parser, yn_parser, noupdate_parser,
                    noupdatedummy_parser, verbose_parser],
        "formatter_class": argparse.RawTextHelpFormatter}

    # Main parser
    parser = argparse.ArgumentParser(
        add_help=False, prog=__prog__,
        parents=[file_parser, format_parser, noupdatedummy_parser,
                 noupdate_parser, repo_parser, link_parser,
                 dryrun_parser, yn_parser, verbose_parser],
        formatter_class=argparse.RawTextHelpFormatter,
        description="Brew-file: Manager for packages of Homebrew\n"
                    "https://github.com/rcmdnk/homebrew-file")

    subparsers = parser.add_subparsers(
        title="subcommands", metavar="[command]", help="", dest="command")

    help = "Install packages in BREWFILE.\n"\
           "Use `--preupdate` to execute `brew update` before install."
    subparsers.add_parser("install", description=help, help=help,
                          **subparser_options)
    help = "Execute brew command, and update BREWFILE."
    subparsers.add_parser("brew", description=help, help=help,
                          parents=[file_parser, format_parser,
                                   yn_parser, verbose_parser],
                          formatter_class=argparse.RawTextHelpFormatter)
    help = "or dump/-i/--init\nInitialize/Update BREWFILE "\
        "with installed packages."
    subparsers.add_parser(
        "init", description=help, help=help,
        parents=[file_parser, format_parser, link_parser, yn_parser,
                 noupdate_parser, noupdatedummy_parser, verbose_parser],
        formatter_class=argparse.RawTextHelpFormatter)
    subparsers.add_parser(
        "dump", add_help=False,
        parents=[file_parser, format_parser, link_parser, yn_parser,
                 noupdate_parser, noupdatedummy_parser, verbose_parser],
        formatter_class=argparse.RawTextHelpFormatter)
    help = "or -s/--set_repo\nSet BREWFILE repository (e.g. rcmdnk/Brewfile)."
    subparsers.add_parser(
        "set_repo", description=help, help=help,
        parents=[file_parser, format_parser,
                 repo_parser, yn_parser, verbose_parser],
        formatter_class=argparse.RawTextHelpFormatter)
    help = "Update BREWFILE from the repository."
    subparsers.add_parser("pull", description=help, help=help,
                          **subparser_options)
    help = "Push your BREWFILE to the repository."
    subparsers.add_parser("push", description=help, help=help,
                          **subparser_options)
    help = "or -c/--clean\nCleanup.\n"\
           "Uninstall packages not in the list.\n"\
           "Untap packages not in the list.\n"\
           "Cleanup cache (brew cleanup)\n"\
           "By drault, cleanup runs as dry-run.\n"\
           "If you want to enforce cleanup, use '-C' option."
    subparsers.add_parser(
        "clean", description=help, help=help,
        parents=[file_parser, format_parser,
                 dryrun_parser, yn_parser, verbose_parser],
        formatter_class=argparse.RawTextHelpFormatter)
    help = "or -u/--update\nDo pull, install, brew update/upgrade, init,\n"\
           "push and clean -C.\n"\
           "In addition, pull, push and clean\n"\
           "will be done if the repository is assigned."
    subparsers.add_parser(
        "update", description=help, help=help,
        parents=[file_parser, format_parser, link_parser, yn_parser,
                 noupdate_parser, noupdatedummy_parser, verbose_parser],
        formatter_class=argparse.RawTextHelpFormatter)
    help = "or -e/--edit\nEdit input file."
    subparsers.add_parser("edit", description=help, help=help,
                          **subparser_options)
    help = "Check applications for Cask."
    subparsers.add_parser("casklist", description=help, help=help,
                          formatter_class=argparse.RawTextHelpFormatter)
    help = "Upgrade cask applications.\n"\
           "With -C, old versions will be removed."
    subparsers.add_parser(
        "cask_upgrade", description=help,
        help=help, parents=[dryrun_parser, yn_parser, verbose_parser],
        formatter_class=argparse.RawTextHelpFormatter)
    help = "Used for test."
    subparsers.add_parser("test", description=help, help=help,
                          formatter_class=argparse.RawTextHelpFormatter)
    help = "or --commands\nShow commands."
    subparsers.add_parser("commands", description=help, help=help,
                          formatter_class=argparse.RawTextHelpFormatter)
    help = "or -v/--version\nShow version."
    subparsers.add_parser("version", description=help, help=help,
                          formatter_class=argparse.RawTextHelpFormatter)
    help = "or -h/--help\nPrint Help (this message) and exit."
    subparsers.add_parser("help", description=help, help=help,
                          formatter_class=argparse.RawTextHelpFormatter)

    if len(sys.argv) == 1:
        parser.print_usage()
        print ""
        print "Execute `" + __prog__ + " help` for more information."
        sys.exit(1)

    if sys.argv[1] == 'brew':
        args = sys.argv[1:]
        if len([x for x in args if x.startswith("-")]) > 0:
            v = sys.version_info
            print 'version =', v
            if v.major == 2 and\
               (v.minor < 7 or (v.minor == 7 and v.micro < 7)):
                print "`brew-file brew ...` with option is available "\
                    "only with Python 2.7.7 or later.\n"\
                    "(Such Yosemite's default is 2.7.6.)\n"\
                    "You can easily install newer version with Homebrew, "\
                    "like:\n"\
                    "    $ brew install python"
                sys.exit(1)
    else:
        (ns, args) = pre_parser.parse_known_args()
        if ns.command is not None:
            args = [ns.command] + args
        else:
            for a in args:
                if a in subparsers.choices.keys():
                    args.remove(a)
                    args = [a] + args
                    break

    (ns, args_tmp) = parser.parse_known_args(args)
    args = vars(ns)
    args.update({'args': args_tmp})

    b.set_args(**args)

    if b.opt["command"] == "help":
        parser.print_help()
        sys.exit(0)
    if b.opt["command"] == "commands":
        commands = ['install', 'brew', 'init', 'dump', 'set_repo', 'pull',
                    'push', 'clean', 'update', 'edit', 'casklist',
                    'cask_upgrade', 'test', 'commands', 'version', 'help']
        commands_hyphen = ['-i', '--init', '-s', '--set_repo', '-c', '--clean',
                         '-u', '--update', '-e', '--edit', '--test',
                         '--commands', '-v', '--version', '-h', '--help']
        options = ['-f', '--file', '-F', '--format', '--form', '-U',
                   '--noupdate', '--preupdate', '-r', '--repo', '-n',
                   '--nolink', '-C', '-y', '--yes', '-V', '--verbose']
        print 'commands', ' '.join(commands)
        print 'commands_hyphen', ' '.join(commands_hyphen)
        print 'options', ' '.join(options)
        sys.exit(0)
    if b.opt["command"] == "version":
        print __prog__ + " " + __version__ + " " + __date__
        sys.exit(0)

    b.execute()

if __name__ == "__main__":
    main()
